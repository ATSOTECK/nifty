// [TOP]
// [HELLO WORLD]
// [COMMENTS]
// [VARIABLES]
// [TYPES]
// [NAMESPACES]
// [PACKAGES]
// [FUNCTIONS]
// [ARGUMENTS]
// [CONTROL FLOW]
// [BLOCK VALUES]
// [RANGES]
// [DEFER]
// [ARRAYS]
// [SLICES]
// [STRING]
// [STRUCTS]
// [STRUCT METHODS]
// [BEHAVIORS]
// [TYPE METHODS]
// [ENUMS]
// [UNION TYPES]
// [GENERICS]
// [UNIONS]
// [POINTERS]
// [FUNCTION POINTERS]
// [MEMORY]
// [OPTIONAL]
// [RESULT]
// [ERROR HANDLING]
// [TESTS]
// [IMPLICIT CONTEXTS]
// [MACROS]
// [MISC]
// [BUILDING] [CONFIG]
// [KEYWORDS]
// [TODO / IDEAS]

// Nifty is a new systems programming language in development. Nifty aims to be a (relatively) simple
// usable, readable, and fast programming language that can use existing c code.

// Nifty is not an OOP language nor does nifty aim for complete safety.

// This file is an overview of the language and (basically) everything in here is
// subject to change. I am open to suggestions and if anything is unclear mut me
// know. This file is much easier to read in vscode with the nifty extension.
// The extension is in the highlighting/vscode folder and you can copy and paste
// it into you vscode extensions folder to install it. You will have to restart
// vscode for it to go into effect.

// This file is meant to describe the nifty programming languiage and will have little to no
// information on the nsl (Nifty Standard Library). That will be described later in other
// files and will likely be an evolving spec.

/-

Naming conventions:

The following naming conventions are used by nifty.
These are not enforced by the compiler and in your code you can use whatever convention you want.

functions:          snake_case
types:              PascalCase or (Pascal_Snake_Case)
enum values:        PascalCase or (Pascal_Snake_Case)
variables:          camelCase or snake_case
macros:             snake_case
macro constants     SCREAMING_SNAKE_CASE
constants:          SCREAMING_SNAKE_CASE
namespace names:    snake_case or flatcase
keywords:           snake_case or flatcase
built-in functions: snake_case
built-in types:     flatcase

The following naming conventions ARE enforced by the compiler.

Exports may not start or end with an underscore.
Namespace private must start with an underscore and can't end with an underscore.
File private must end with an underscore.

-/

// [HELLO WORLD] ----------------------------------------------------------------------------------

using fmt;

fn main() {
    println("Hello, world!");
}

// Semicolons are required but will generally be omitted in this document.

// [COMMENTS] -------------------------------------------------------------------------------------

// Single line comments use '//'.
// This is a comment.

/-
    Multiline comments use '/-' and '-/'
    Comments can be nested so the following is valid
-/

/-
    /-
        // bla
    -/
-/

/- Multiline comments can be on just one line too -/

/*
    C-style comments can be used as well and mixed with nifty comments.
*/

/-
    Like so
    /*
        and so
    -/
*/

// Why not just use /* */? I'm lazy, but you do you.

// [VARIABLES] ------------------------------------------------------------------------------------

// Variables are declared with the 'mut' keyword.
mut x: int = 12 // int
// With type infrence.
mut x = 12

// The variable declaration operator can be used as well.
x := 12 // int
y := 12.f // f32
y := 12.0 // f64
y := 12.d // f64

// The types are inferred but can be specified.
mut x: int = 12
x: int = 12 // Invalid.
mut y: f64 = 10 // Valid.

// If no value is specified the type must be specified
mut x // Invalid
mut x: int // Valid
x: int // Invalid.

// Immutable variables (runtime constants) are declared with the 'const' keyword.
const x = 12

// The constant declaration operator can be used as well.
x ::= 12

// The type is inferred for constants as well but it can also be specified.
const x: int = 12
x :: int = 12 // Invalid.
const y: int // Invalid, immutable variables must have their value specified.

// Variables are auto initialized in Nifty.
mut x: int
y := x // Valid, both will be type int with value 0

// Variables can be explicitly uninitialized
mut x: int = undefined
x := undefined // Invalid.
x: int = undefined // Invalid.

// Multiple variables can be explicitly undefined with 'undefined'

undefined {
    mut x: int
    mut y: float
    mut z: string
}

// x, y, and z are all defined but uninitialized.

// It is important to know that undefined is only used for declaring variables. 
// You can't check to see if a variable is undefined.
if (x == undefined) // Invalid
// Because of this undefined is NOT null
undefined == null // Invalid

// A variabled can't be later set to undefined.
x := 12
x = undefined // Invalid

buf: u32 = undefined
bufNum := buf // Valid but undefined behavior. buf could be anything. Should this warn?

// Immutable variables can not be set to undefined.
const y: int = undefined // Invalid, immutable variables must have their value specified.

// Nifty does not support variable shadowing.

fn someFunc(x: int) {
    x := 12 // Invalid
}

fn someFunc() {
    someVar := 12
    {
        someVar := 42 // Invalid
    }
}

// Return variables can also be unused.

// Because unused is a reserved identifier it can be redefined
unused := someFunc()
unused := someOtherFunc()
unused = aThirdFunc()

// unused can't be constant.
unused ::= anotherFunc() // Invalid

//unused is not a real variable, and thus doesn't have a value.
x := unused // Invalid
fmt::println(unused) // Invalid
typename_of(unused) // Invalid

// Variables can have attribues.
#[static]
y := 42 // static variable

#[thread_static]
x := 12 // thread static variable

// [CONSTANTS] ------------------------------------------------------------------------------------

// Compiletime constants use the 'constexpr' keyword and their value must be determined at compile time.
constexpr x = 12
constexpr y = someFunc() // Invalid
constexpr z = #MACRO_CONST // Valid
constexpr w = #constEvalFunc() // Valid

// The constant declaration operator can be used as well.

x ::= 12

// The compiler will differenciate between a runtime constant and a compile time
// constant so the same operator can be used.

// Constants can't be undefined or unused either.

// [TYPES] ----------------------------------------------------------------------------------------

// Basic Types:
char // same width as u32 defaults to '\0'
int // same as s32 defaults to 0
uint // same as u32 defaults to 0
float // same as f32 defaults to 0.f
double // same as f64 defaults to 0.d

unit // number between 0 and 1 inclusive. Same size as f32

uintptr // defaults to 0

// defaults to false
bool // Same as b32?
b8 b16 b32 b64

// defaults to 0
u8 u16 u32 u64 u128
s8 s16 s32 s64 s128

byte // Same as u8

// defaults to 0.0
f16 f32 f64 f128

// defaults to ""
string

// defaults to "\0"
cstring // Null terminated string. Meant for interfacing with c libraries.

typeid // runtime identifier for a type
unknown_type // Like unknown in typescript.

rawptr // Like void* in c, used for compatibility with existing c code.

// Custom types can be created as follows:

typedef Custom as int
mut var: Custom
assert(typename_of(var) == "Custom") // True

fn takeCustom(c: Custom) { /- ... -/ }
mut a: Custom
mut b: int
takeCustom(a)
takeCustom(b) // Valid

if (a == b) // Valid

// To force Custom to be distinct from int use the distinct attribute.
#[distinct] typedef Custom as int

takeCustom(a)
takeCustom(b) // Invalid

if (a == b) // Invalid, implicit casting not supported.
if (cast(a, int) == b) //Valid
if int(a) == b // Also valid

// A new default value can be given for distinct types.
#[distinct, init_to=1] typedef Month as int
mut month: Month // month is 1

// Casting uses the 'cast' operator.
x: s8 = 100
y := cast(x, s32) // cast(var, type)

// Casting can also be of the form type(var)
y := s32(x)

// Generally speaking using 'cast' is preferred as it is searchable and usually more clear.
// Sometimes the form type(var) is easier to read. For example this
return u8(abs(s8(n)));
// is easier to undestand than this.
return cast(abs(cast(n, s8), u8));

// To cast between two types of the same size you can use the 'recast' operator. 
// Like reinterpret_cast in c++.
mut x: f32 = 12.0
y := recast(x, u32)

// This is similar to the following pointer cast manipulation:
mut x: f32 = 12.0
y := cast(^u32, &x)^

// Though recast doesn't require taking the address of the value which is not always possible.

// There is a third casting operator called 'auto_cast'.
x := 12.f
y := 19
// ...
y = auto_cast(x)

// auto_cast is convienient but potentially unsafe.

y = cast(x, type_of(y)) // Like auto_cast

// Types in nifty are not implicitly converted.

x := 12
y := 42
z: f64 = x / y // Invalid
z: f64 = cast(x, f64) / cast(y, f64) // Valid
z: f64 = f64(x) / f64(y) // Valid
z: f64 = cast(x / y, f64) // Valid, but probably not what you want.
z: f64 = f64(x / y) // Valid, but probably not what you want.

// Implicit upcasting is allowed though.
x: f16 = 1.f
y: f32 = x
z: f64 = y

x := 12
if (x) { /- ... -/ } // Invalid
if (x != 0) { /- ... -/ } // Valid

b := true
if (b) { /- ... -/ } // Valid
if (b == true) { /- ... -/ } // Valid

p: ^int = null
if (p) { /- ... -/ } // Invalid 
if (p != null) { /- ... -/ } // Valid

opt? := 7
if (opt) { /- ... -/ } //Valid
if (opt != null) { /- ... -/ } //Valid

// Nifty supports hex, octal, and binary numbers
x := 0xff // or 0xFF
y := 0q72 // octal uses q because using o is less readable
z := 0b1011011

// Numbers can also have underscores for better readability.
x := 1_000_000
y := 0xFF_AA_12
z := 0xBAD_F00D

// Nifty has raw strings, to use raw string use back ticks.

str := `this\is\'a\raw\string`

// [NAMESPACES] -------------------------------------------------------------------------------------

// All nifty programs are made of a collection of namespaces.

namespace main

// Namespaces are used with the 'use' keyword.
use fmt
use math

fn main() {
    fmt::println(math::PI)
}

// If no namespace is specified for a file then the default 'default' namespace is used.

using fmt
use 'foo'

fn main() {
	println("Hello world!")
    foo::bar()
}

// By default the name of the namespace is the last element of the namespace 
// path, which is also the name of the namespace in the file. This, however,
// can be changed with the 'as' keyword

use fmt
use math as M
use math::random

fn main() {
    fmt::println(M::PI) // math::PI is invalid
    fmt::println(random::number())
}

// Note the 'random' is a namespace inside the 'math' namespace and must be used
// separately from 'math'.

// All items inside a namespace can be added to the current scope with the 'using' keyword.

use fmt
using fmt // All items exported from the fmt namespace are now in this file's scope.

fn main() {
    println("Yo whaddup?")
}

// --- --- --- --- ---

use fmt

fn sayHi() {
    using fmt // All items from the fmt namespace are now in this function's scope.
    println("Hello")
}

fn main() {
    fmt::println("Yo whaddup?")   
}

// 'using' can also be used to import the namespace and bring it in to the file scope.
using fmt

fn main() {
    println("Hello world!")
}

// If two namespaces are brought into the same scope and they have any exported symbols
// with the same name then the namespace name must be provided to avoid ambiguity.

use fmt
use "foo"

using fmt
using foo // Lets say that nanespace 'foo' also has a println function.

fn main() {
    println("Ya yeet") // Invalid
    foo::println("Yote") // Valid
}

// Namespaces in the nifty standard library (nsl) or the include directories are used without
// double quotes while user made namespaces are included with double quotes.
use fmt // nsl namespace
use "foo::bar" // non-nsl namespace (user made)

// Specific functions or types can be used from a namespace as well.

use fmt{ println }

fn main() {
    println("Hello world!")
    fmt::print("fmt is still used!\n")
}

// This will still use the fmt namespace but it brings just println into the current scope.
// This can be a good alternative to the 'using' keyword as it decreases the chances of name collisions.

// The 'as' keyword can still be used
use fmt{ println as pln } as F

use math::random{ int64, float64 }

use os::io::file
use os::io::folder

use os::io::{ file, folder } // file and folder are namespaces
use math::random{ int64, float64 } // int64, float64 are functions

use nsl::io
use nsl::mem
use nsl::unicode::utf8{ String }
use nsl::bytes

// Is the same as

use nsl::{ io, mem, unicode::utf8{ String }, bytes }
use nsl::{
    io, 
    mem,
    unicode::utf8{ String },
    bytes
}

// Is the same as

use io
use mem
use unicode::utf8{ String }
use bytes

use "game"::{ map, object } // use game, map, object namepaces
use "game"{ run, quit } // run, quit are functions

// When importing specifics like this the 'using' keyword can not be used.

// All items not starting or ending with an underscore are exported from the namepace.

namespace example

mut _privateVar: int // Private to the namespace.
mut exportedVar: f64
mut localVar_: string // Private to the file.

const exportedConst = 100
const _privateConst = 42
const localConst_ = 12

fn _somePrivateFunction() {
    // Do something
}

fn exportedFunction() {
    // Do something
}

fn localFunction_() {
    // Do something
}

typedef _PrivateStruct struct {
    // Stuff
}

typedef ExportedStruct struct {
    // Stuff
}

typedef LocalStruct_ struct {
    // Stuff
}

// etc...

// You might be thinking what if you have
mut _someVar_: string
// Then what will happen? In this case the compiler will default to the most private case.
// So _someVar_ will be a local variable (private to the file).
// It is not recommended to start and end with an underscore though and this may generate
// a warning.

// Underscores can be used in variable names in other contexts with no warnings, though it isn't
// always recommended.
fn someFunc(_someVar, secondVar_, _thirdVar_: int) { /- ... -/ } // Nothing special about any of these args.

fn otherFunc() {
    // Stuff
    _x := 12 // Nothing special about _x or x_ or _x_ here.
}

// Sometimes you only want to expose an api for your namespace without exposing the implementation.
// For that you can use the 'api' keyword. A namespace may have at most one api file. All functions,
// structs, variables, etc must be public and must not start or end with an underscore. The idea is
// to be similar to header files in c/c++.
// These files should be named namespace_name.api.nifty For example the api file for the game namespace
// would be game.api.nifty The api file must be in the same folder as the namespace for development.
// Using a namespace with an api file works like using any other namespace.
// Everything listed in an api file must be defined and implemented in the namespace.

// TODO: Should there be an option to generate the api file for a given namespace automatically?
// This would only included exported symbols in the namespace.

api game // The game namespace must be defined and implemented.

// Items should be defined as they are in the namespace.
// Otherwise a warning will be issued.

// Functions must not be defined.
fn drawText(x, y: f32, text: string, fontSize: u32, color: Color)
fn createRobot(x, y: f32, health: int): ^Robot
fn doSomethingWithAMatrix(m: matrix::Matrix)

// Invalid, functions can't have implementations.
fn sayHi() {
    fmt::println("hi")
}

// It is ok to redefine structs/enums/behaviors/types in the api file.
typedef Circle struct {
    x, y: f32
    r: int = 100
}

// Even though the functions are not being implemented here the impl, constimpl, and endimpl
// keywords are used here.
impl Circle
    md draw(color: Color)
endimpl

typedef Collection<typename T> struct { /- snipped -/ }

// The same for generics. (Pretend Collection is defined above, it is defined in [GENERICS] though)
impl Collection<typename T>
    md init(size := 0)
    md add(num: T)
    md average(): float
endimpl

impl Collection<int>
    md sum(): int
endimpl

// The use of indentation above is optional, I just think it is easier to read this way when there
// is no implementation.

typedef Align enum {
    Vertical,
    Horizontal,
}

// Variables may be defined or undefined. Unlike normal variable declarations variables
// must be explicetly set.
mut defaultAlignment = Align.Vertical
mut defaultFont: ^Font = undefined
const DEFAULT_FONT_SIZE = 42
// If a variable does not match the definition in the namespace a warning will be issued.

// An option would be to set them to undefined and explain the default in a comment.
/// Defaults to vertical
mut defaultAlignment: Align = undefined
/// Defaults to "Comic Sans" aka the font of Champions.
mut defaultFont: ^Font = undefined


// Declaration operators can be used as well.
isFullscreen := false

// [PACKAGES] -------------------------------------------------------------------------------------

// Packages are collections of namespaces.

package nsl namespace io

// So the io namespace belongs to the nsl package.

// Packages can be used like a namespace.

use nsl
nsl::os::exit(1)

use nsl::{ os }
os::exit(1)

using nsl::{ os }
exit(1)

using fmt
using nsl::fmt

// Packages can't be used without namespaces.

package engine // Invalid
package engine namespace map // Valid

// Packages are not needed.

namespace map // Valid

// Smaller programs probably have no need for packages but larger more complicated programs should
// probably use them.

// The api keywork can't be used with packages, only with namespaces.

api nsl // Invalid because nsl is a package.

use nsl::math::random
math::PI
random::int64()

// [FUNCTIONS] ------------------------------------------------------------------------------------

// Functions are declared with the 'fn' keyword.

fn someFunc() {
    // Do something
}

// Functions can have arguments.
fn sayHi(name: string) {
    fmt::println("Hi", name)
}

// ...and a return type
fn add(a: int, b: int): int {
    return a + b
}

// Functions in nifty can only return one value. To return multiple values you can use a tuple.
fn doSomething(): .{int, string} {
    mut n: int
    mut str: string
    // Do stuff
    return .{n, str}
}

// See the tuples section for more information in how tuples work in nifty.

fn someFunc(): int { /- ... -/ }
a := someFunc() // Valid
unused := someFunc() // Valid

// It is important to note that if unused is used like this the value is still being passed from the
// function. If this usecase is common and performance is critical then it is recommended to make
// another function that excludes that return value. (or could this be optimized away with the fast
// option by creating and calling modified copies of the function that omit that specific return?)

// If two or more consecutive arguments have the same type, the type can be omitted for all but the
// last argument of that type.
fn add(a, b: int): int {
    return a + b
}

// Functions can have default arguments
fn add(a := 10, b := 10): int {
    return a + b
}

// Here type inference was used for the argument types but they can be specified as well.
fn add(a: int = 10, b: int = 10): int {
    return a + b
}

// Non-default arguments can't come after default arguments.

// Invalid
fn add(a := 10, b := 10, c: int): int {
    return a + b + c
}

// If a function returns something the type must be specified in the function definition.
// A function can be explicitly marked as not having a return value. This is purely for the
// programmers convenience, there is no difference to the compiler. 

fn yeet(): void {
    fmt::println("Yeet")
}

// Function argument names can be used.
fn someFunc(start, stop: int) { /- ... -/ }

someFunc(start: 0, stop: 100) // Named arguments must still be in the order they were defined in.
someFunc(stop: 100, start: 0) // Invalid
someFunc(start: 0, 100) // Valid, the order is preserved so the compiler knows 100 is stop.
someFunc(theStart: 0, theStop: 100) // Invalid, names must match the prototype definitions.

// All function arguments are immutable.
fn someFunc(x: int) {
    x = 12 // Invalid
    y := &x // Invalid
}

// If you need to change the argument for some reason you must either make a copy or use the 'mut' keyword.
fn someFunc(x: int) {
    newX := x
    newX = 12 // Valid
}

// Explicitly mark x as mutable with the 'mut' keyword.
fn someFunc(mut x: int) {
    x = 12 // Valid
    y := &x // Valid
}

// Pointers can also be used to change the value.
fn someFunc(x: ^int) {
    newX := x
    newX^ = 12
}

mut x: ^int = new int
x^ = 2
someFunc(^x) // See section on pointers for an explination.
// x is now 12

// varargs
// Functions can be variadic, meaning they can take a variable number of arguments.
// The variadic argument can be treated like a static array.
fn sum(nums: ..int): int {
    res := 0
    for (const n in nums) {
        res += n
    }
    
    return res
}

sum()
sum(1)
sum(1, 2, 3)
sum(4, 5, 6, 7, 8)

// If a variadic function requires a minimum number of arguments to work, that can be specified with min_arity(int).

#[min_arity=2]
fn sum(nums: ..int): int {
    res := 0
    for (const n in nums) {
        res += n
    }
    
    return res
}

sum() // Invalid
sum(2, 2) // Valid

// max_arity(int) can also be used.
// Did you know that a function with 9 arguments is called Novenary? Well now you do!

// Arguments can't come after a variadic argument.
fn counts(cnts: ..int, type: string) // Invalid

// Nifty has function overloading, but it works differently compared to languges like c++.
// Instead of two functions having the same name but different arguments the functions have
// different names and are explicetly overloaded. For instance if you had a pow function for
// int, float, and double it might look like this:

fn powi(x: int, y: int): int { /- ... -/ }
fn powf(x: float, y: float): float { /- ... -/ }
fn powd(x: double, y: double): double { /- ... -/ }

fn pow overloads {powi, powf, powd} // Called a function group?

// This is done to be more explicit and searchable as well as making the compiler simpler to develop.

// The original functions can still be called or the overloaded function can be called.
a := 2.f
b := 8.f
x := 2
y := 8

z := powi(x, y)
w := pow(x, y) // Calls powi()
v := pow(a, b) // Calls powf()
u := powf(a, b)

// The following will not compile:

fn pow(x: int, y: int): int { /- ... -/ }
fn pow(x: float, y: float): float { /- ... -/ }
fn pow(x: double, y: double): double { /- ... -/ }

// Sometimes you want to guarantee the return variable is handled.
// no_discard can be used to force the return variable to be used.
// Equivalent to [[nodiscard]] in c++.

#[no_discard]
fn returnsError(): Error {
    // do stuff
}

// This will force the caller to handle the returned error.

// Do something
returnsError() // Invalid
// Do more things

// Do something
err := returnsError() // Invalid, err isn't being used.
// Do more things

// Do something
err := returnsError() // Valid
if (err != 0) {
    // Handle error.
}
// Do more things

// Using try on a function that returns an error with no_discard is fine because that error is used.
try returnsError() // Valid

// unused can be used to ignore return values from functions marked with no_discard.
unused := returnsError() // Valid

// Should unused be allowed to work with error (or Result) returns? Probably? Not all errors are
// important. Maybe a warning could be emitted if unused is used on functions that return an error
// (or Result).

// Functions can have preconditions or postconditions.
// Preconditions use the require attribute.
#[require {x > 0 && x < 1_000} ensure {return > 0}]
fn someFunc(x: int): int {
    return x * 10
}

// Postconditions use the ensure attribute.
#[ensure {return <= a && return <= b}]
fn min(a, b: s32): s32 {
    if (a < b) {
        return a
    }
    return b
}

// Note that the attributes in the form attribute{code} are to catch compiletime errors and are not
// available via reflection. User attributes can't be in the form of attribute{code}.

// Where possible require and ensure will be checked at compiletime. In debug mode asserts will be
// added to catch runtime require/ensure errors.

// In debug mode the above two functions would effectively be:
#[require {x > 0 && x < 1_000}, ensure {return > 0}]
fn someFunc(x: int): int {
    assert_db(x > 0 && x < 1_000)
    _return := x * 10
    assert_db(_return > 0)
    return _return
}

#[ensure {return <= a && return <= b}]
fn min(a, b: s32): s32 {
    if (a < b) {
        _return := a
        assert_db(_return <= a && _return <= b)
        return _return
    }
    _return := b
    assert_db(_return <= a && _return <= b)
    return _return
}

// This can be used for optimizations.

fn example(n: int): int {
    if (someFunc(n) == 0) {
        return -1
    }
    return 1
}

// can be optimized to

fn example(n: int): int {
    return 1
}

// Because someFunc() can never return 0.

// For functions that take pointers, paramater attributes can be used to control the dataflow.
#[in="a", inout="b", out="c"]
fn takesPtrs(a, b, c: ^int) { /- ... -/ }

// in disallows writing to the pointer.
// out disallows reading from the pointer.
// inout allows reading and writing and is the default.

// Note that if in is used and the pointer is passed to second function that second function may be
// able to write to the pointer unless it also has the 'in' restriction. 'in' only guarantees that
// the function it is applied to won't directly write to the pointer. Same issue with 'out'.

// Functions can be inlined with the 'inline' attribute.
#[inline]
fn smallFastFn() { /- ... -/ }
// Or explicetly not inlined with the 'no_inline' attribute.
#[no_inline]
fn bigSlowFn() { /- ... -/ }
// Let the compiler decide if it should be inlined or not. This is the default, but can be explicetly stated.
#[maybe_inline]
fn someOtherFn() { /- ... -/ }

// Function calls can also be inlined.
fn someFunc(): int { /- ... -/ }

fn otherFunc() {
    x := #[inline] someFunc()
}

// someFunc() is inlined in otherFunc()

// Functions can have one or more attribues.
#[attribName, attribName2=value]
fn bar() { /- ... -/ }

#[deprecated="Function 'foo' is deprecated, use 'bar' instead."]
fn foo() { /- ... -/ }

#[deprecated="DO NOT USE"]
fn badFunc() { /- ... -/ }

// With deprecated_after the deprecated warning will onlt be shown after the given date.
#[deprecated="Use X instead.", deprecated_after="2023-10-20"] // yyyy-mm-dd
fn eventuallydeprecated() { /- ... -/ }

// deprecated_after can be used on its own. The equivalent of using deprecated with no message specified.
#[deprecated_after="2023-10-20"] // yyyy-mm-dd
fn eventuallydeprecated() { /- ... -/ }

#[warning="ABANDON ALL HOPE YE WHO ENTER HERE"]
fn reallyBadFunc() { /- ... -/ }

#[no_discard, maybe_unused]
fn bla(): int { /- ... -/ }

// Custom attributes can be used as well as attributes provided by the compiler.
// For instance routing for a webserver backend.

#[route="/user/:id", method="get"]
fn getUserForId(id: string): User! {
    return // Return code here.
}

// Without the suppress this function would cause a warning.
#[suppress_warning="warning_name"] 
fn someFuncThatCausesWarning(thing: unknown_type) {
    // ...
}

// See the result section for information on what User! means.

// In the web namespace it would be able to look at the attributes attached to this function using
// reflection and be able to do what it needs to do.

// Built-in function attributes.
/- 
no_discard
min_arity(argc: int)
max_arity(argc: int)
deprecated(msg: string = "")
deprecated_after(date: string) // yyyy-mm-dd
maybe_unused
warning(msg: string)
static // Like static in c/c++.
require_target_feature(feature: string)
no_return
asm_return // Indicates that the function returns via inline assembly instead of a return statement.
inline
no_inline
maybe_inline
no_context
trace_vars(names: ..string) // Prints the values of the variables listed every time they change.
                           // This is meant for debugging and will be relatively slow.
suppress_warning(wanring_name: string)

// Called at the end of the callers scope.
deferred_in(function: fn) // Receives the same paramaters as the called function.
deferred_out(function: fn) // Receives the results of the called function.
deferred_in_out(function: fn) // Receives both the input and output of the called function.
deferred_none(function: fn) // Receives no input.
These can be useful but are not always recommended as they can make it not obvious why a function
is being called without further investigation. May get rid of these.

link_name(name: string)

require {code}
ensure {code}
in(vars: ..string)
out(vars: ..string)
inout(vars: ..string)
-/

#[link_name="llvm.cos.f64"]
fn cosf64(f64): f64 undefined

// [ARGUMENTS] ------------------------------------------------------------------------------------

// Arguments in nifty are passed as an array of strings.

using fmt;

fn main(args: []string) {
    println("{} args", args.length());

    for const arg in args {
        println(arg);
    }
}

// [CONTROL FLOW] ---------------------------------------------------------------------------------

// For loops work much like they do in c/c++

for mut i = 0; i < 10; ++i {
    // Do something
}

for i := 0; i < 10; ++i {
    // Do something
}

// But also have ranges

for (0 ..= 10) { /- ... -/ } // [a, b]
for (0 ..< 10) { /- ... -/ } // [a, b)
for (0 ..= 10; 2) { /- ... -/ } // Uses a step of 2 instead of 1
for (const i in 0 ..< 10) { /- ... -/ }
for (const i in 0 ..= 10; 2) { /- ... -/ } // Uses a step of 2 instead of 1
for (const str in strings) { /- ... -/ }
for (const str, index in strings) { /- ... -/ }
for (mut str in strings) { /- ... -/ }
for (const key, value in map) { /- ... -/ }
for (const key, value, index in map) { /- ... -/ }

for 10 ..< 0 { /- ... -/ } // Does nothing

// To go backwards over a range use <-
for <-(10 ..< 0) { /- ... -/ }
for <-(const str in strings) { /- ... -/ }
for <- 10 ..< 0 { /- ... -/ }
for #reverse const str in strings { /- ... -/ }
for #reverse const i in 10 ..= 0 { /- ... -/ }

// To unroll a loop use #unroll
for #unroll 0 ..< 10

// The range must be known at compiletime to use #unroll

len ::= some_func()
for i in 0 ..< len { /- ... -/ }

// While loops work like they do in c/c++.

while condition == true {
    // Do something
}

// For a do ... while loop use #[at_least_once]
#[at_least_once]
while condition == true {
    // Code ran at least once
}

// Until loops. The opposite of while loops. AKA while (!(condition == true))

until condition == true {
    // Do something
}

// For a do ... until loop use #[at_least_once]
#[at_least_once]
until condition == true {
    // Code ran at least once
}

until (window.shouldCLose()) {
    // Game loop.
}

// Is the same as
while (!window.shouldClose()) {
    // Game loop.
}

// When statements are much like switch statements in c/c++ except they only need one dedicated
// keyword.

x := 2
when x {
    1: fmt::println("one")
    2: fmt::println("two")
    3: fmt::println("three")
    else: fmt::println("???")
}

// Multiple cases can be handled at once.

when x {
    1, 3, 5, 7, 9: fmt::println("odd")
    2, 4, 6, 8, 10: fmt::println("even")
    else: fmt::println("???")
}

// Ranges can also be used.

when x {
    in 0 ..< 10: fmt::println("0 ..< 10")
    in 10 ..= 100: fmt::println("10 ..= 100")
    else: fmt::println("big")
}

// By default cases do not fall through. To fall through use 'fallthrough'.

x := 2
when x {
    1: fmt::println("one"); fallthrough;
    2: fmt::println("two"); fallthrough;
    3: fmt::println("three");
    else: fmt::println("???");
}

// Functions can be used as the conditions. If the function returns true then it executes that
// branch.
when x {
    is_even(x): fmt::println("Even!");
    is_odd(x): fmt::println("Odd!");
}

// You can provide the operator that should be used for number types.
x := 12
when x {
    < 12: fmt::println("x is less than 12!");
    12: fmt::println("x is 12!");
    > 12: fmt::println("x is greater than 12!");
}

x ::= random::int32()
when x {
    < 5, 6, is_even(x): fmt::println("x is < 5, or x id equal to 6, or even!");
}

when x {
    < 5, > 6, is_even(x): fmt::println("x is < 5, or x is > 6, or even!");
}

when X {
    !5: fmt::println("x is not 5");
    else: fmt::println("x is 5");
}

// The above when statement will trigger 2 and 3.

// When is not just limited to numbers.

str := "one"
when (str) {
    "one": fmt::println("1")
    "two", "three": fmt::println("2 or 3")
    else: fmt::println("???")
}

strs0 := []string{"one", "two", "three"}
strs1 := []string{"four", "five", "six"}
str := "two"

when (str) {
    in strs0: fmt::println("1, 2, or 3")
    in strs1: fmt::println("4, 5, or 6")
    else: fmt::println("???")
}

typedef Value as double | string | bool;
mut v: Value // Has type double with value 0

when (type_of(v)) {
    double: fmt::println("v is a double");
    string: fmt::println("v is a string");
    bool: fmt::println("v is a bool");
}

when v {
    as double: fmt::println("v is a double");
    as string: fmt::println("v is a string");
    as bool: fmt::println("v is a bool");
}

// Each case in a when statement has its own scope. Curly braces are required.

str := "one"
when str {
    "one": {
        x := 1
        fmt::println(x)
    }
    "two": {
        x := 2
        fmt::println(x)
    }
    else: fmt::println("???")
}

// Values can be set to the result of when.

str ::= "one"
x := when str {
    "one": yields 1;
    "two": yields 2;
    else: yields 0; // Must have an 'else' unless when is checking an enum and it is complete. 
}

typedef Some_enum enum {
    Value1,
    Value2,
}

thing ::= Some_Enum::Value1;
x := when thing {
    Some_Enum::Value1: yields 1;
    Some_Enum::Value2: yields 2;
    // No else needed since it's complete.
}

// When statements don't always need to have an else: but it is a good idea to have them.
// else: works a bit differently if using when on an enum. See the enums section for an explanation.

// If statements. Work how they do in c/c++ (parens are optional) with the addition of elif.

if thing {
    // Do something 1
} else if thing2 {
    // Do something 2
} elif thing3 {
    // Do something 3
} else {
    // Do something 4
}

// Sometimes the programmer knows that a branch of code will never be executed. The compiler can be
// told this with the 'unreachable' keyworkd.

fn foo(x: int) {
    m ::= x % 3;

    when m {
        0: fmt::println("Foo");
        1: fmt::println("Bar");
        2: fmt::println("Baz");
        else: unreachable;
    }
}

re ::= regex::compile("valid-regex-here") else unreachable;

// If unreachable is exucuted the program will panic in debug mode. In release mode the compiler
// assumes the code will never be executed to perform optimizations. Hitting unreachable in
// release is undefined bahavior.

// Logic operators work the same as in c/c++.
// && for and
// || for or
// ! for not
// | bit or, & bit and, ~ bit xor(binary), ~ bit not(unary), << lsl, >> lsr

// Ternary operator. Ternary operators can't be nested.

valueIfTrue ::= 12
valueIfFale ::= 42
condition := true
x := condition ? valueIfTrue : valueIfFale
assert(x == 12) // true

condition = false
x = condition ? valueIfTrue : valueIfFale
assert(x == 42) // true

// Labels are defined with #labelName!
#someLabel!

// Labels can be used with continue, break, and goto.
// Yes nifty has goto, however use of goto is disabled by default. Misuse of goto can quickly cause
// messy code but it can be very powerful in specific senarios. So I see no reason not to include it.

#forever!
// Code
goto #forever!

// goto can't jump to labels in other functions.

// Continue and break

for i := 0; i < 10; ++i {
    if i % 2 == 0 {
        fmt::println("even")
        continue // Will exit this loop and continue the loop.
    }
    
    fmt::print("odd")
}

found := false
for const v in someArray {
    if v == target {
        found = true
        break // Will exit this loop but will not continue the loop.
    }
}

// Labels can be used with break and continue as well. For instance if you have and inner and
// outer loop you can use labels to specify which loop to break/continue from. Otherwise
// nifty will break/continue from the loop the statement is in which may not be what you want.

#outer!
for i := 0; i < 100; ++i {
    #inner!
    for j := 100; j >= 0; --j {
        if someCondition {
            continue #inner!
        }
        
        if otherCondition {
            break #outer!
        }
        
        // Stuff
    }
    
    // Stuff
}

// [BLOCK VALUES] ---------------------------------------------------------------------------------

// Blocks are expressions and can be used to get values.

count := {
    mut sum: u32
    for (i: u32 = 0; i < 10; ++i) {
        sum += 1
    }
    yields sum // This "returns" sum.
}

// Sometimes it's impracticle or not possible to initialize/set a variable in one line. Using
// blocks can prevent needing to set the variable to undefined or a temporary value.

// Blocks can be labbeled as well to return a value from a specified block if nested.

x := aNumber()

count2 := #outerBlock! {
    mut sum: u32 = #innerBlock! {
        for (i: u32 = 0; i < 10; ++i) {
            sum += 1
        }
        
        if (x > 20) {
            yields #outerBlock! sum
        }
        
        yields #innerBlock! sum
    }
    
    for (i: u32 = 0; i < 10; ++i) {
        sum += 1
    }
    yields sum
}

// [RANGES] ---------------------------------------------------------------------------------------

1 ..= 5 // [1, 5] 1, 2, 3, 4, 5
1 ..< 5 // [1, 5) 1, 2, 3, 4

range := 0 ..= 10 // type range
x := 12

if x in range {
    // Do something
}

for const v in range {
    fmt::println("v ", v)
}

fmt::println(range.low, ", ", range.high) // 0, 10

// Modifying a range.
range.low = 5;
range.high = 20
range.inclusive = false;

typedef Range behavior {
    low: int;
    high: int;
    inclusive: bool;
}

// Maybe? Not sure if I want a range type or not.

// [DEFER] ----------------------------------------------------------------------------------------

// 'defer' defers the execution of code until the end of the current scope.

fn someFunc() {
    // stuff
    someFile.open("myFile.txt")
    defer someFile.close()
    // more stuff
}

// Blocks of code can be deffered as well.

fn anotherFunc() {
    defer {
        call1()
        if (condition) {
            call2()
        }
    }
    // stuff
}

// Defer statements can be stacked as well and are executed in a First In Last Out (FILO) fashion.

namespace main
using fmt

fn main() {
    for (const i in 0 ..< 5) {
        defer println(i)
    }
    println("Hello world")
}

/- Will print the following:
Hello world
4
3
2
1
0
-/

// Nifty has a second type of defer, defer_err. defer_err only runs if the function returns an error.
// This can only be used in function that returns a Result. This is because if the function returns
// an Errorable then it would always be called because the function would always have to return an
// Errorable. In that case defer should be used. defer_err is run in a FILO fashion as well.

// defer_success
fn someFunc(str: string): ^Value! {
    someVar := new(Value)
    someVar->thing = "bla";
    defer_err free(someVar)
    
    if (someVar->count() < 10) {
        return Error("count() is less than 10!") // defer_err is run here.
    }
    
    if (someOtherCondition) {
        return Error("Some other condition was met!") // defer_err is run here.
    }
    
    // defer_err is not run here.
    return someVar
}

// See the Result section for an explanation on ^Value!.

// [ARRAYS] ---------------------------------------------------------------------------------------

// Static arrays
mut arr: [5]int // Array of 5 integers, auto initialized to [0, 0, 0, 0, 0]
arr := [5]int{1, 2, 3, 4, 5} // Array of 5 integers initialized to [1, 2, 3, 4, 5]
arr := [?]int{1, 2, 3, 4, 5} // Array of 5 integers where the length is inferred.
arr := [1, 2, 3, 4, 5] // Array of 5 integers where the length and type are inferred.
arr := [5]int{5} // Array of 5 integers initialized to [5, 5, 5, 5, 5]
arr := [5]int{5, 6} // Array of 5 integers initialized to [5, 6, 0, 0, 0] or should this not compile?
arr: [5]int = undefined // Array of 5 integers not initialized to anything.

// Dynamic arrays
mut arr: []int // Array with length 0 and capacity 0
arr := []int{} // Array with length 0 and capacity 0
arr := []int{cap: 100} // Array with length 0 and capacity 100 initialized to []
arr := []int{len: 3, cap: 100} // Array with length 5 and capacity 100 initialized to [0, 0, 0]
arr := []int{len: 3, cap: 100, init: 2} // Array with length 5 and capacity 100 initialized to [2, 2, 2]

arr := []int{len: 10, cap: 0} // Invalid, cap must be >= length

// Note that static arrays all have their cap specified (or use ?) inside [], or are directly set via [].
// Dynamic arrays always have [] left blank. Dynamic arrays are also set differently.
arr := []int{1, 2, 3} // Invalid. Dynamic arrays can't be set like this.
arr: []int = [1, 2, 3] // Valid, dynamic.
arr: [?]int = [1, 2, 3] // Valid, static.

// Arrays created with the new keyword are dynamic
arr := new [5]int // Dynamic array with length 0, capacity 5
arr := new [n]int // Dynamic array with length 0, capacity n
arr := new []int  // Dynamic array with length 0, capacity 0
arr := new [?]int // Invalid.

// Arrays are 0 indexed.
arr := [1, 2, 3, 4, 5]
x := arr[0] // x is 1
arr[2] = 12 // [1, 2, 12, 4, 5]

// Arrays are bounds checked at compile time (where possible) and runtime.
// Nifty can be set to only bounds check in debug mode.
x := arr[5] // Compile time error.
arr[12] = 42 // Compile time error.

y := 5
x := arr[y] // Runtime error.

// Runtime bounds checking can be disabled at a block level with #no_bounds_check
// This can be important in situations where performance is critical. Could lead to undefined behavior.
#no_bounds_check {
    x = arr[y] // y could still be out of bounds.
}

// To get the length of an array use the included length() function.
assert(arr.length() == 5) // true
// To get the capacity of an array use the included capacity() function.
assert(arr.capacity() == 5) // true
// To get the number of open slots in an array use the included open_slots() function.
assert(arr.open_slots() == 0) // true

arr := []int{len: 5, cap: 100, init: 12} // [12, 12, 12, 12, 12]
assert(arr.length() == 5) // true
assert(arr.capacity() == 100) // true
assert(arr.open_slots() == 95) // true

// To append to an array use the included append() function.
// Will error on static arrays.
arr.append(4) // [5, 5, 5, 5, 5, 4]
// Multiple values can be appended at once.
arr.append(6, 7, 8, 9) // [5, 5, 5, 5, 5, 4, 6, 7, 8, 9]
arr.prepend(12) // [12, 5, 5, 5, 5, 5, 4, 6, 7, 8, 9]

arr.clear() // []

// Arrays can be multidimensional.
mut arr: [][]int // 2D array of int
arr := {
    {1, 2, 3, 4},
    {5, 6, 7, 8}
}

arr[1][2] // 7
arr[0] // [1, 2, 3, 4]

// [SLICES] ---------------------------------------------------------------------------------------

// Slices are like arrays but can be more accurately thought of as a view into the array.
// A slice is created by specifying the start index and the end index.

array[low : high]

array := [1, 2, 3, 4, 5, 6, 7]
arr := array[1:4] // Includes elements 1 through 3. [2, 3, 4]

// The following expressions are all equivalent.
array[0:7]
array[:7]
array[0:]
array[:]

// Slice literal.
slice := [:]int{1, 2, 3} // Creates an array with [1, 2, 3] then creates a slice for it

// Slices have length, size and capacity.
arr := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
slice := arr[1:5] // [1, 2, 3, 4]

slice.length() // 4
slice.size() // 4
slice.capacity() // 0

newSlice := slice[0:20] // Compiler error. End is out of bounds of the array.

arr := [5]int{0} // [0, 0, 0, 0, 0]
slice := arr[1:5] // [0, 0, 0, 0]

slice[0] = 12 // slice is now [12, 0, 0, 0] arr is now [0, 12, 0, 0, 0]

// [STRING]

str := "hello " ## "world" // String concatination.
str := "hello " + "world" // String concatination.

str.length() // Number of characters.
str.size() // Sixze in bytes.

// [STRUCTS] --------------------------------------------------------------------------------------

typedef Point struct {
    x: int,
    y: int,
}

mut p: Point
p.x = 12
p.y = 42

point: Point = {x: 12, y: 42} // Valid
point: Point = {12, 42} // Valid
point: Point = {} // Valid, x and y are set to 0, same as mut point: Point
point: Point = {12} // Invalid, either all values must be set or no values are set
point := Point{x: 12, y: 42} // Valid
point := Point{x: 12} // Valid, y is 0
point := {x: 12, y: 42} // Invalid, other types could have an x and y.

// Default values can be given for strcut fields.

typedef Point3D struct {
    x: f64 = 100.f
    y: f64 = 100.f
    z: f64 = 1.f
}

// This allows structs to be uninitialized.

typedef Point3D struct {
    x: f64 = undefined
    y: f64 = undefined
    z: f64 = undefined
}

// Default values can be blocked when declaring the variable.

typedef Point struct {
    x: int = 12
    y: int = 42
}

mut p: Point = undefined
x := p.x // Undefined behavior, x can be anything.

typedef Point struct: undefined {
    x: int = 10
    y, z: int
}

// or should it be ???

#[undefined]
typedef Point struct {
    x: int = 10
    y, z: int
}

// y and z will default to undefined while x will default to 10

// Fields on a struct can be marked as required. Meaning that field must be specified when creating
// an instance of the struct.
typedef Foo struct {
    bar: int #[required]
    baz: int
}

foo := Foo{} // Invalid
foo := Foo{bar: 100} // Valid
foo := Foo{bar: 100, baz: 200} // Valid

// If fields in a struct are of the same type then they can be on the same line.

typedef Point3D struct { x, y, z: f64 }
point := Point3D{y: 12.f, Z: 42.f} // Valid

// You can also set fields on the same line to the same value.
typedef Point3D struct { x, y, z: f64 = 100.f }
typedef Point3D struct { x, y, z: f64 = undefined }

// Nifty supports embedded structs.
typedef Size struct { w, h: int }
typedef Position struct { x, y: f32 }

// Size and Position are embedded into Button
typedef Button struct {
    ...Size
    ...Position
    title: string
}

button := Button{x: 100, y: 100: w: 256, h: 64, title: "Yeet"}

// Spread operator on struct instances.
typedef Person struct {
    name: string
    age: int
    job: string
}

fn assignJob(person: Person, job: string): Person {
    return Person{
        ...person,
        job: job
    }
}

p := Person{name: "Joe", age: 27}
p = assignJob(p, "Programmer")
fmt::println(p.job) // Programmer

// structs can have read only fields by using the const keyword.

typedef Config struct {
    const host: string  // Must be set on int, can't be changed.
    const port: string  // Must be set on int, can't be changed.
    name: string
}

typedef Config struct { const host, const port, name: string }

cfg := Config{} // Invalid
cfg := Config{host: "::", port: "7777"} // Valid

// Struct pointer ownership

// Adding @ to the end of a pointer type type indicates that the object pointed to is owned by the
// struct and should be deleted when the struct is deleted.

typedef Node struct { left, right: ^Node@ } // left and right are automatically deleted when the
                                         // struct object is deleted.

// Structs can also have attributes.

#[packed] // Will not add padding
typedef Packed struct {
    x: f64
    y: s16
}

// Preconditions can be stated. Where possible this will be checked at compile time. In debug mode
// asstert_db statements will be inserted to verify the precondition.

#[require {min <= max}]
typedef Range struct { min, max: int }

range := Range{2, 1} // Invalid

range := Range{x, y}
assert_db(range.min <= range.max) // Added if in debug mode.

/- Built-in struct attributes
packed
align(alignment: int)

require {code}
-/

// Attributes can be applied to struct fields as well.

typedef Person struct {
    id:        int        #[json="id", norm="index"]
    name:      string     #[json="name"]
    holding:   []string   #[json="holding", omitempty]
    createdAt: time::Time #[json="created_at"]
}

// [STRUCT METHODS] -------------------------------------------------------------------------------

// For methods the md keyword is used so that if the impl keyword is missed by a 
// programmer or a programmer jumps to the middle of the file it is obvious that
// these are methods and not ordinary functions. The fn keyword can be used as 
// well if preferred. The md keyword can't be used outside an impl.

typedef Collection struct {
    list: []int
    _average: float // Private variable
}

impl Collection

// Nifty does not have constructors/destructors.

md init(size := 0) {
    list = []int{size: size}
}

md add(num: int) {
    append(list, num)
    _calculateAverage()
}

// Functions can be marked as read only, meaning they can't modify the struct at all.
#[read_only]
md average(): float {
    return _average
}

// Private function
md _calculateAverage() {
    total := 0
    for (const num in list) {
        total += num
	}

	average = cast(total, f32) / cast(list.length(), f32)
}

endimpl

// Optionally the name of the struct can be specified with endimpl.
endimpl Collection
// This is just to improve readability in files with multiple struct implementations.
// This does not allow for impl nesting.

collection := Collection{}
collection.init(100)

collection := new Collection{ /- ... -/ } // Type is ^Collection. 
// The values can be specified.
collection := new Collection // Invalid
collection := new Collection{} // Valid

// To make collection an optional pointer:
mut collection: ^Collection? = new Collection{}
// Or more succinctly
mut collection? = new Collection{}
collection? := new Collection{}

collection := new Collection{list: []int{}} // Private variables can't be set here.

collection->add(12) // Valid
// Is effectively the same as (but is not the same as)
add(collection, 12) // Invalid

// The calling object is implicetly passed in like 'this'.

collection = null
collection->add(12) // The function add will not be called. This will panic.

if (collection != null) {
    collection->add(12) // No error.
}

// If you don't allocate the object on the heap this is not an issue.

collection := Collection{list: []int{}} // Type is Collection.
collection := Collection // Invalid
collection := Collection{} // Valid
collection.add(12)

// You may have noticed that I used both '->' and '.' when calling the 
// functions. Nifty works like c++ in that objects that are pointers use 
// '->' and objects that are not pointers use '.'. This is to visually 
// distinguish the two.

// A struct can be implemented multiple times in the same namespace.

namespace session

use net::http

typedef Session struct {
    // ...
}

impl Session

md request(method http::Method, url: string, body: []byte = null): http::Response! {
    // ...
}

endimpl

// In a file called users.nifty in the session namespace.

namespace session

use net::http
use fmt
using "model"

impl Session // Valid.

md get_user[session: ^Self](user_id: string): User! {
    // ...
    // Note that the session receiver argument is not required here. I just like this style better.
    resp ::= try session->request(http::Method::Get, fmt::sprintf("{}/api/v1/users/{}", session->host, user_id))
    resp ::= try request(http::Method::Get, fmt::sprintf("{}/api/v1/users/{}", host, user_id)) // Also valid.
    // ...
}

endimpl

// In file not in the session namespace.

namespace service

using "session"

impl Session // Invalid.
// ...
endimpl


// To prevent multiple implementations the 'constimpl' keyword can be used.

namespace session

typedef Session struct {
    // ...
}

constimpl Session
// ...
endimpl

// In a file called users.nifty in the session namespace.

namespace session

impl Session // Invalid.
// ...
endimpl


// Multiple constimpl can be used within the orginal file the struct is defined in. 
// With generics there are cases where it may make sence to have seperate implementations
// for different types.

// To print a struct type use the fmt::Printable behavior.

typedef Color struct { r, g, b: u8 }

impl Color does fmt::Printable // Behavior must be specified on every impl.

md str(): string {
    return fmt::sprintf("{}, {}, {}", r, g, b)
}

endimpl

color := Color{51, 153, 255}
fmt::println("The color is {}.", color)

// When implementing functions on a struct the structs fields are implicitly available to the
// function body. Optionally functions implemented on a struct can have a receiver argument. The
// receiver argument is in brackets right before the functions parentheses. The struct type name
// can be used for the type.

typedef Thing struct {
    x: int
}

impl Thing

md yeet[mut this: ^Self]() {
    this->x = 12
    x = 42 // Invalid
}

md yert[mut this: ^Thing]() {
    this->x = 12
    x = 42 // Invalid
}

md yote(newX: int) {
    x = newX
    this->x = newX // Invalid
}

// Pass receiver by value.
md printX[t: Thing]() {
    fmt::println(t.x)
    t.x = 12 // Invalid
}

// Pass receiver by mutable value.
md localSetX[mut t: Thing]() {
    fmt::println(t.x)
    t.x = 12 // Valid, but done on a copy of the receiver argument.
}

md read_onlyPtr[this: ^Self](n: int) {
    this->x = n // Invalid
}

endimpl

// The functions are called the same as any other.
mut thing: Thing
thing.yeet()
thing.yert()
thing.yote(12)
thing.printX()

// [TYPE METHODS] ---------------------------------------------------------------------------------

// Methods can be added to any distinct type.
// Methods can't be added to built in types.

#[distinct, init_to=1] typedef Month as int

impl Month does fmt::Printable

md str[m: Month](): string {
    when (m) {
        1: return "January"
        2: return "February"
        // etc...
        else: return "???"
    }
}

endimpl

mut month: Month
fmt::println(month) // Prints January.
month++
fmt::println(month) // Prints February.

// [BEHAVIORS] ------------------------------------------------------------------------------------

// Behaviors are a a way to define shared behavior. To indicate that an implementation does a
// certain behavior the 'does' keyword is used. Implementations can do one or more behaviors.

// If an implementation does a behavior then all the functions in the behavior must be 
// implemented or there will be a compiler error. If an implementation does multiple behaviors
// with conflicting function names then there will be a compiler error. If a behavior and an
// impl have conflicting function names there will be a compiler error. Or should it require 
// prefixing with the BehaviorName.

use math

typedef Rect struct { w, h: f64 }
typedef Circle struct { r: f64 }

typedef Geometry behavior {
    area(): f64
    perim(): f64
    kind: string
}

typedef Arc behavior {
    partialArea(percent: f64): f64 // The argument name is optional here.
    partialArea(f64): f64 // The same
}

impl Rect does Geometry

md area(): f64 {
    return w * h
}

md perim(): f64 {
    return 2 * w + 2 * h
}

endimpl

impl Circle does Geometry, Arc

md area(): f64 {
    return math::PI * r * r
}

md perim(): f64 {
    return 2 * math::PI * r
}

md partialArea(percent: f64): f64 {
    return area() * percent
}

endimpl

rect := Rect{100, 100, "rect"}
circle := Circle{10, "circle"}

fmt::println(rect.kind) // Because Rect does Geometry it "inherits" the kind variable. 
// I use the word inherits here but that is not entirly correct. The kind variable gets added to
// the end of the implementing struct in the order the behaviors were listed at compile time.
// Or should it be at the beginning? Should this be configurable?

// Behaviors can be used as parameters to define a function that can take many types that all share
// that behavior.

fn printArea(shape: does Geometry) {
    fmt::println(shape.area())
}

// printArea accepts any type that does Geometry.

// This is the same as the above.
fn printArea<typename T: Geometry>(shape: T) {
    fmt::println(shape.area())
}

// This function is fine and allows for shape1 and shape2 to be different types.
fn printAreas(shape1, shape2: does Geometry) { /- ... -/ }
fn printAreas<typename T: Geometry, typename U: Geometry>(shape1: T, shape2: U) { /- ... -/ } // Same as above.

// To require that shape1, and shape2 be the same type
fn printAreas<typename T: Geometry>(shape1, shape2: T) { /- ... -/ }

// Multiple behaviors can be required.
fn printAreaAndShape(shape: does Geometry & fmt::Printable) {
    fmt::println(shape.area())
    fmt::println(shape)
}

fn printAreaAndShape<typename T: Geometry & fmt::Printable>(shape: T) { /- ... -/ }

// This works for structs as well.
typedef Shape struct {
    geometry: does Geometry
    otherVar: int
}

// Is the same as:
typedef Shape<typename T: Geometry> struct {
    geometry: T
    otherVar: int
}

// Behaviors can be combined into new behviors via type intersections.

typedef PrintableGeometry as Geometry & fmt::Printable

impl Rect does PrintableGeometry
// ...
endimpl

// Type intersections can only be used with behaviors.
// If two behaviors have conflicting symbols then the name of the bahavior must be used.

typedef Drawable behavior {
    draw()
}

typedef Text behavior {
    draw()
}

typedef UiText struct {}

impl UiText does Drawable, Text

fn Drawable::draw() {
    // do stuff
}

fn Text::draw() {
    // do stuff
}

endimpl

mut t: UiText
t.Drawable::draw()

// Behaviors can have overridable function implementations

#[require_constimpl]
typedef Allocator behavior {
    alloc(type: typeid): rawptr
    free()
    
    md printStats() {
        fmt::println("Allocated {} bytes.", allocated)
    }
    
    allocated: int
}

// These overridable function implementations can't be called directly from the behavior but if a
// struct impl does the behavior it "inherits" that function.

typedef MyAllocator struct {}

constimpl MyAllocator does mem::Allocator

md alloc() { /- ... -/ }
md free() { /- ... -/ }

endimpl

allocator := MyAllocator{}
// Use the allocator.
allocator.printStats() // Prints number of bytes allocated.

// This allows for bahaviors to have optional functions that wont case a crash if they are called.
// These overridable function implementations can access any variables defined in the behavior but
// not variables in the struct that implements the behavior.

typedef MyAllocator struct {
    freed: int
}

constimpl MyAllocator does mem::Allocator

md alloc() { /- ... -/ }
md free() { /- ... -/ }

md printStats() {
    fmt::println("Allocated {} bytes, freed {} bytes.", allocated, freed)
}

endimpl

allocator := MyAllocator{}
// Use the allocator.
allocator.printStats() // Prints number of bytes allocated and freed.

// [ENUMS] ----------------------------------------------------------------------------------------

typedef Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL,
    TK_FUNCTION,
    TK_VAR,
}

// The above example is just like enums in c/c++. So TK_STRING = 0, TK_NUMBER = 1 ...

typedef Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL = 5,
    TK_FUNCTION,
    TK_VAR,
}

// Unless otherwise specified enumerators take the value of the enumerator before them + 1.
// TK_STRING = 0, TK_NUMBER = 1, TK_BOOL = 5, TK_FUNCTION = 6 ...

// The values in an enum must be unique.

typedef Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL = 5,
    TK_FUNCTION,
    TK_VAR = 6, // Invalid
}

// More advanced patterns can be used as well for the increments.
typedef EvensForSomeReason enum {
    unused = #jot * 2,
    First,  // 2
    Second, // 4
    Third,  // 6
}

typedef EvensForSomeReason enum {
    First = (#jot + 1) * 2,  // 2
    Second, // 4
    Third,  // 8
}

typedef Permission enum {
    Read = 1 << #jot, // 00000001
    Write,            // 00000010
    Delete,           // 00000100
}

typedef MemSize enum {
    unused = 1 << (#jot * 10),
    KB, // dec: 1024       bin: 00000000000000000000010000000000
    MB, // dec: 1048576    bin: 00000000000100000000000000000000
    GB, // dec: 1073741824 bin: 01000000000000000000000000000000
}

// 'jot' works much like 'iota' in go (the etymology nerds out there should love this).

// Enums can be types other than int. When this is the case all enumerators must be specified.

typedef Numbers enum: f64 {
    PI = 3.14159,
    E = 2.71828,
}

typedef Animals enum: string {
    Aardvark = "aardvark",
    Cat = "cat",
    Dog = "dog",
}

// using can be used on enums.

typedef Numbers enum: f64 {
    PI = 3.14159,
    E = 2.71828,
}

// ...

using Numbers // Bring Numbers enumerations into the current scope.

num := PI // Valid
e := Numbers.E // Unlike with namespaces the name can still be used with using.

typedef Direction enum {
    North,
    South,
    East,
    West,
}

mut dir: Direction = Direction.North

when (dir) {
    Direction.North: fmt::println("north")
    Direction.South: fmt::println("south")
    else: fmt::println("other") // Because we are using when on an enum else must be used to cover
    // the other cases.
}

// The complete attribute can be used to force all of the options to be considered in the when.
// else: can't be used with complete. complete can only be used with enums, otherwise it is a
// compiler error.

#[complete]
when (dir) {
    Direction.North: fmt::println("north")
    Direction.South: fmt::println("south")
    Direction.East: fmt::println("east")
    Direction.West: fmt::println("west")
}

when (dir) {
    Direction.North: fmt::println("north")
    Direction.South: fmt::println("south")
    Direction.East: fmt::println("east")
    Direction.West: fmt::println("west")
    else: unreachable
}

// Functions can be implemented on enums as well.

typedef Color enum {
    Yellow,
    Red,
    Green,
    BLue,
}

impl Color

md greenPart[c: Color](): bool {
    when (c) {
        Color.Yellow,
        Color.Blue: return true
        else: return false
    }
}

md isGreen[self: Self](): bool {
    return self == Color.Green
}

endimpl

c := Color.Green
assert(c.isGreen()) // True

// [UNION TYPES] ----------------------------------------------------------------------------------
// tagged unions

// Nifty has union types.

typedef Value as bool | s32 | f128 | string

// When using union types like this the default value is the default for the first type in the
// union.

mut value: Value
assert(type_of(value) == bool) // True
assert(value == false) // True

mut value: Value = undefined // Valid
assert(type_of(value) == bool) // True

assert(size_of(Value) == 16) // True

v: Value = 12
assert(typename_of(v) == "s32") // True
assert(type_of(v) == s32) // True

when (type_of(v)) {
    bool: v = !v
    s32: v = 42
    f128: v = 123.456
    string: v = "yeet"
}

// Note that when using when with type_of -> and else: can't be used. All types in the union
// type must be cases in the when. Only the types in the union type can be used. It is better to
// use type_of instead of typename_of with when as typename_of returns a string an the compiler won't
// know if all the types and only the correct types are being used.

v = "yote" // v is type string now.
assert(typename_of(v) == "string") // True
assert(type_of(v) == string) // True

s1 := v.(string) // Go style type assertion. Bad.
s1 := type_assert(v, string) // Will panic if v is not of type string.
s1 := v as string // Will panic if v is not of type string.

// To do a type assertion without panicing use an if statement.
mut s1: string
if type_of(v) == string {
    s1 = v
}

// Or

s1 := v as string else "" // Will not panic if v is not of type string.

// Union types have a hidden tag that keeps track of what that last type the union variable was set
// to. This is used internally for when, and type checking.

s2 := v // Valid. s2 is type Value

mut s3: string
s3 = v // Invalid
s3 = v as string // Valid.

// Union types can not have arrays as a type in the union. (?)

// [GENERICS] -------------------------------------------------------------------------------------

fn add<typename T>(a, b: T): T {
    return a + b
}

typedef Point<typename T> struct {
    x: T
    y: T
}

// What if you wanted to store more than just int in the Collection struct above?
// Well then you would need to use generics.

typedef Collection<typename T> struct {
    list: []T
    _average: float // Private variable
}

impl Collection<typename T>

md init(size := 0) {
    list = []T{size: size}
}

md add(num: T) {
    append(list, num)
    _calculateAverage()
}

md average(): float {
    return _average
}

// Private function
md _calculateAverage() {
    total := 0
    for (const num in list) {
        total += num
	}

	average = cast(total, f32) / cast(len(list), f32)
}

endimpl

collection := new Collection<f32>{}
collection->add(12.f)

// You can also restrict methods to a certain type.

impl Collection<int>

md sum(): int {
    total := 0
    for (const num in list) {
        total += num
	}
}

endimpl

// The sum function is only available for Collection<int>.

collectionInt := new Collection<int>{}
collectionF32 := new Collection<f32>{}

// do stuff

sumInt := collectionInt->sum() // Valid
sumF32 := collectionF32->sum() // Comile error

// Generics are figured out at compile time so there is no runtime cost assosiated with them.

// You can specify what types are allowed to be used

typedef Vec3<typename T: int | float | double> struct {
    x: T
    y: T
    z: T
}

fn add<typename T: int | float | double>(a, b: Vec3<T>) { /- ... -/ }
fn sub<typename T: int | float | double>(a, b: Vec3<T>) { /- ... -/ }

// To make using multiple types like this easier you can use union types.

typedef IFD as int | float | double

// The above struct and functions could be re-writen like:

typedef IFD as int | float | double
typedef Vec3<typename T: IFD> struct { x, y, z: T }

fn add<typename T: IFD>(a, b: Vec3<T>) { /- ... -/ }
fn sub<typename T: IFD>(a, b: Vec3<T>) { /- ... -/ }

// If you want to make the above struct work so that any type of number can be used, but only numbers
// you can use the #number built-in macro.
typedef Vec3<typename T: #number> struct { /- ... -/ }

// Or if you only want to allow only all floating types only you can use the #decimal built-in macro.
typedef Vec3<typename T: #decimal> struct { /- ... -/ }

// Or if you only want to allow only all integer types only you can use the #integer built-in macro.
typedef Vec3<typename T: #integer> struct { /- ... -/ }

// Or if you only want to allow only all signed types only you can use the #signed built-in macro.
typedef Vec3<typename T: #signed> struct { /- ... -/ }

// Or if you only want to allow only all unsigned integer types only you can use the #unsigned built-in macro.
typedef Vec3<typename T: #unsigned> struct { /- ... -/ }

// Or if you only want to allow only all boolean types only you can use the #boolean built-in macro.
// Limited to bool, b8, b16, b32, b64
typedef Vec3<typename T: #boolean> struct { /- ... -/ }

// I thought about having a number, decimal, and integer keywords but I don't think this would come up
// enough to merit three dedicated keywords.

// These conveniences (#number, #decimal, and #integer) only work with generics.
mut num: #number = 12 // Invalid

// The union types work for impl or functions as well

impl Vec3<typename T: int | float | double>
impl Vec3<typename T: IFD>
impl Vec3<typename T: #number>

fn add<typename T: int | float | double>(a, b: T) { /- ... -/ }
fn add<typename T: IFD>(a, b: T) { /- ... -/ }
fn add<typename T: #decimal>(a, b: T) { /- ... -/ }

// Type 'void' can not be used as a type for generics.
typedef Thing<typename T> struct { /- ... -/ }
mut thing: Thing<void> // Invalid
impl Thing<void> // Invalid

typedef Table_Slot<typename K, typename V> struct {
    occupied: bool;
    hash: u32;
    key: K;
    value: V;
}

typedef Table<typename K, typename V> struct {
    count: int;
    allocator: mem::Allocater;
    slots: []Table_Slot<K, V>;
}

fn allocate(table: ^Table<$K, $V> capacity: int) {
    //
}

fn find(table: Table<$K, $V>, key: K): V {
    //
}

t := Table<string, int>{}
// ...
v ::= find(table, "yeet")

// Generics can use type intersections with behaviors. See the behaviors section for info.

// [UNIONS] ---------------------------------------------------------------------------------------

// Unions will work much like they do in c.

typedef Data union {
    i: int,
    f: f32,
    d: f64,
}

// i, f, and d all share the same memory address.

fn someFunc() {
    mut data: Data
    data.i = 10
    fmt::println("data.i is {}", data.i) // Will print "data.i is 10"
    data.f = 12.34f // Overwrites data.i
    fmt::println("data.i is {}", data.i) // Will print something else.

    fmt::println(size_of(data.i)) // 4
    fmt::println(size_of(data.d)) // 8
    fmt::println(size_of(data)) // 8
}

// Unions are untagged and can be used to reinterpret memory. Sometimes this behavior is desired,
// but otherwise this could result in bugs that may not be obvious. In general tagged unions are
// preferred as they are safer because they require type assertions to use. Untagged unions should
// only be used in specific cases.

// As an example of where untagged unions would be desireable:

typedef Value union {
    bits64: u64,
    bits32: [2]u32,
    num: double,
}

// The type Value takes advantage of how pointers work in 64 bit systems to enable a technique
// called NaN boxing. This is very useful if you are writing a vm for a dynamically typed scripting
// language for instance.

// Anonymous unions can be used as well. Anonymous unions are also untagged.

typedef Vec2<typename T: #number> struct {
    union { x, w, u: T },
    union { y, h, v: T },
}

typedef Vec2f as Vec2<f32>

fn someFunc() {
    pos := Vec2f{10, 123}
    fmt::println("position: ({}, {})", pos.x, pos.y)

    size := Vec2f{100, 100}
    fmt::println("width: {}, height: {}", size.w, size.h)
    fmt::println("width: {}, height: {}", size.x, size.y) // Same as above
    fmt::println("width: {}, height: {}", size.u, size.v) // Same as above
}

// [POINTERS] -------------------------------------------------------------------------------------

// Pointers in nifty use the Pascal syntax.
// For types '^' is on the left and indicates it is a pointer type.
// For dereferencing '^' is on the right of the variable. 
// Like c/c++ '&' is the addressof operator.

mut p: ^int // Pointers are null by default so p is null.
x := 12
p = &x // p now points to x
y := p^ // y is 12
p^ = 42 // x is 42


// Pointers to compiletime/runtime constants are constant as well.
const z = 12
ptr := &z
ptr^ = 42 // Invalid

const z = getInt()
ptr := &z
ptr^ = 42 // Invalid

// Nifty does not have pointer arithmetic.
mut p: ^int = someFunc()
p++ // Invalid, this is supported via multi-value pointers.

// If the compiler knows that a value is null when it is being dereferenced is will not compile.
mut p: ^f64
p^ = 12 // Invalid

mut p: ^f64
// ...
p^ = 42 // Causes a panic if p is still null.

// If a function takes a pointer type then ^ is used on the left of the variable
// to visually indicate that.

fn someFunc(x: ^int) {
    // Do something
}

x := 12
y: ^int = &x

someFunc(^y) // Valid
someFunc(y) // Invalid
// This is not dereferencing y or doing anything other than passing y.
// This is just so the programmer can quickly see this function is taking
// a pointer and that y could potentially be modified by the function.
// TODO: Is this more annoying than it's worth?
// TODO: Maybe this can be optional and forced by a compiler flag?

// Pointers passed to functions can't be null by default.
fn takesPtr(ptr: ^int) {
    x := ptr^ // No need to check if ptr is null.
}

// assert_db will automatically get inserted into the function to make sure the pointer is not null.

fn takesPtr(ptr: ^int) {
    assert_db(ptr != null)
    x := ptr^
}

ptr := new int{12} // ptr^ is 12
// ...
takesPtr(^ptr) // Invalid, ptr could be null

if (ptr != null) {
    takesPtr(^ptr) // Valid
}

// To indicate that a function can take null pointers:
fn takesPtr(ptr?: ^int) {
    //
}

mut ptr: ^int
takesPtr(^ptr) // Valid


// Optional pointers can be used for increased safety. Optional pointers must be unwrapped to be
// dereferenced. This avoids accidentally trying to use a null pointer or an already freed pointer.
mut ptr: ^int? = null // Valid
mut ptr: ^int? // ptr has no value, is null
x := 12
ptr = &x
mut y: int

if ptr; [mut p] {
    p^ = 12
}

// To unwrap an optional pointer simply use it in an if statement.
if (ptr != null) {
    // ptr is now ^int, this is the only place nifty supports variable shadowing.
    assert(ptr^ == 12) // True
}

// Another way to unwrap the pointer is with the '?' operator.
assert(ptr?^ == 12) // True
ptr = null
assert(ptr?^ == 12) // False
// Would the above be
assert(null == 12) // ???


// ptr is type Optional<^int>

// To return an optional pointer '?' is used as well.
fn returnsOptionalPointer(): ^int? { /- ... -/ }

// To indicate an optional pointer in a callback definition:
fn callsCallback(callback: fn(^int?): int)
// Or the name of the argument can be used.
fn callsCallback(callback: fn(arg: ^int?): int)

// Nifty has null coalescing.

x := 12
p: ^int = &x

y := p^ ?? 12
// The above line is the same as
mut y: int
if (p != null) {
    y = p^
} else {
    y = 12
}

p ??= &x
// The above line is the same as
if (p == null) {
    p = &x
}

mut ptrptr: ^^int = undefined // Invalid. 

// For multiple indirection/pointer arithmetic multi-value pointers are used.
mut values = [1, 2, 3, 4, 5]
mut valuesPtr: [^]Value = &valuesArr

assert(valuesPtr[0] == 1) // True
assert((valuesPtr + 3)[0] == 4) // True
valuesPtr++
assert(valuesPtr[0] == 2) // True

// Bounds checking applies to multi-value pointers as well. #no_bounds_check can be used too.
valuesPtr += 10 // Invalid
valuesPtr[10] // Invalid

valuesPtr^ = 10 // Invalid
valuesPtr[0] = 10 // Valid

// [FUNCTION POINTERS] ----------------------------------------------------------------------------

fn addFn(a, b: int): int {
    return a + b
}

fn otherFunc() {
    add := addFn // Type is ^fn(int, int): int
    add(2, 2)
}

typedef AddFn as fn(int, int): int

fn add(a, b: int): int { /- ... -/ }
typedef AddFn as type_of(add) // Also works

// [MEMORY] ---------------------------------------------------------------------------------------

// TODO: Figure this out. Incomplete.

// Nifty is a manual memory management based language. Meaning that programmers must manage their
// own memory. Similar to c/c++. 

fn new(type: typeid, allocator: ^Allocator_Type = null): ^typeid! {
    ret := cast(allocator->alloc(size_of(type)), ^type)
    if ret == null {
        return error::OutOfMemory
    }

    return ret
}
// Allocates memory for the given type and initializes it to it's defualt values.
// If the allocator passed is null then use the allocator in the current context.

fn new_undefined(type: typeid, allocator: ^Allocator_Type = null): ^typeid!
// Allocates memory for the given type.
// If the allocator passed is null then use the allocator in the current context.

fn free(ptr: rawptr, allocator: ^Allocator_Type): error

n := new(int)
n^ = 12
free(n)

fmt::println("n", n^) // Undefined behavior

n = null
fmt::println("n", n^) // Prints "n: null"

x := new(int, custom_allocator)
free(x, custom_allocator)

// Allocate memory for a Person type and point person to that memory and wrap it in an optional.
person? := new(Person)
person := new(Optional<^Person>)

if person => [const p] {
    p->doAThing();
    free(person)
}

n := new(int)
n^ = 12
n = free(n) // Free n and set it to null. Maybe emit a warning if the user only frees and
            // doesn't set the pointer to null.

// To create a custom allocator you must use constimpl and use the mem::Allocator behavior.

namespace custom_alloc

use mem

typedef CustomAlloc struct {} // The struct doesn't (technically) need any fields.

constimpl CustomAlloc does mem::Allocator

md alloc<typename T>() { /- ... -/ }
md free<typename T>()  { /- ... -/ }

endimpl

// ...

using "custom_alloc"

// Custom allocators can be used with the 'new' keyword.

myAllocater := CustomAlloc{}
ptr := new(int, myAllocater)

// Bydefauly new will use the current context's allocator.
myAllocater := CustomAlloc{}
context->allocator = myAllocater

ptr := new(int) // Allocated with CustomAlloc
// The same as 
pre := new(int, context->allocater)


// Memory mest bee freed with the allocator it was allocated with.

free(ptr) // Invalid if the context allocator isn't myAllocater
free(ptr, myAllocater) // Valid

// or

customAlloc := CustomAlloc{}
ptr := customAlloc.alloc(int)

// To free all memory from an allocator mem::free_all can be used.
// To reallocate use mem::realloc.
// The specifics of these will be worked out later.

// [OPTIONAL] -------------------------------------------------------------------------------------

// Nifty has an optional type that can be used. Optional, is used by default.
// The idea is to have a way to have a variable with no value without crashing or panicking in any
// situation. Optional can only cause a panic if the programmer explicitly wants to panic.

fn someFunc(): Optional<string> {
    // ...
    if (someCondition) {
        return "a string" // Return does have a value.
    }
    
    return null // Return doen't have a value.
}

const opt = someFunc()
str := opt.valueElse("yeet") // str will be yeet if opt has no value, otherwise it is the contained value.

// Or
str := someFunc().valueElse("yeet")

// Another way to handle optionals is via else.
str := someFunc() else { "yeet" }
str := someFunc() ?? "yeet";

// There can be more than one statement in the block. If that is the case then 'yields' must be used to
// "return" the value. If return is used it will return from the containing function.
str := someFunc() else {
    fmt::println("someFunc() was empty, defaulting to yeet.")
    yields "yeet"
}
// str is set to "yeet" on empty

// Instead of writing out Optional a question mark can be used instead.
fn someFunc(): string? { /- ... -/ } // Same as fn someFunc(): Optional<string>

// Optionals can be in function arguments too.
fn anotherFunc(arg1: string?, arg2: string, arg3: string?): int
// Because optionals still have to be passed you can have a non-optional after an optional.

// Default values can be used as well.
fn anotherFunc(arg1: string?, arg2: string, arg3: string? = null): int

// Optionals can be used with pointers.
mut opt: Optional<^int> // Default for Optional is null.
mut opt: ^int? // Same as the above line
// This is detailed more in the [POINTERS] section.

opt.set(p) // Value is now p.

opt? := SomeStruct{id: "12"}
// Is the same as
mut opt: SomeStruct? = SomeStruct{id: "12"}

mut x: int? // x is null
mut y: int

if (x != null) {
    y = x
}

y = x else { 12 };
y = x ?? 12;

y = x else unreachable;
// Is the same as
y = x.?;

// Optionals can't be of type 'void'.
fn returnsNothing(): void? // Invalid

// Included functions.
md valueElse(other: T): T // If the optional is null then other is returned. The other value can't be nullable.
md valueElseFn(other fn(): T ): T // If the optional is null then other is returned.
md valueElseDefault(): T // If the optional is null then the default value for the type is returned.
md valueElsePanic(msg: string): T // Panics with the given message if the optional is null, otherwise returns the value.

md hasValue(): bool // Returns true if it has a value.
md isNull(): bool  // Returns true if it is null.
md clear() // Set to null.
md set(value: T) // Set the value of the optional.

md value(): T // For compiler use only.

// With payload capturing.
if opt => [const v] {
    assert(v == 12)
}

if opt => [mut v] {
    //
}

// With parens

if (opt) => [const v] {
    //
}

// Access by reference
if opt => [mut ^v] {
    v^ = 1
}

if opt => [const v] {
    assert(v == 1)
}

// [RESULT] ---------------------------------------------------------------------------------------

// Results are a lot like optionals, except that results either have a value or an error.

fn someFunc(): Result<string> {
    if (someCondition) {
        return "a string"
    }
    
    return Error("this is an error")
}

// Like optionals, results have a syntax shortcut.

fn someFunc(): string! { /- ... -/ } // Same as above.

result := someFunc()
str := result.valueElsePanic(result.err())

str := someFunc() else {
    panic(error.msg()) // error is automatically defined in the else block
}

// If error is already defined or you just want to use a different name you can. Or you can
// explicitly define error. Noe that 'e' is only defined in that block.
str := someFunc() => [const err] {
    panic(err)
}

str := someFunc() else { "yeet" } // Ignore the error and set to "yeet".
str := someFunc() else "yeet" // Ignore the error and set to "yeet".
str := someFunc() ?? "yeet" // Ignore the error and set to "yeet".

str := someFunc() else {
    fmt::println(error)
    yields "error :("
}

str := someFunc() ?? { // Invalid. Can't use ?? here.
    fmt::println(error)
    yields "error :("
}

// This pattern:
str := someFunc() else { return error }
// Is the same as: 
str := try someFunc()
str := short someFunc()
// This is not try as in try catch. try evaluates the Result and if it has an error it returns the
// error. Nifty does not have exceptions or a catch keyword.

// Included functions.
md valueElse(other: T): T // If the result has an rror then other is returned. The other value can't be nullable.
md valueElseFn(other fn(): T ): T // If the result has an error then the result of the provided function is returned.
md valueElseDefault(): T // If the result has an error then the default value for the type is returned.
md valueElsePanic(msg: string): T // Panics with the given message if the result has an error, otherwise returns the value.

md hasValue(): bool // Returns true if it has a value.
md hasError(): bool  // Returns true if it has an error.
md clear() // Clears the value/error.
md setValue(value: T) // Set the value of the optional.
md setError(err: does Errorable) // Set the value of the optional.

if result; const value {
    assert(value  == 12)
} else; err {
    panic(err)
}

// The error is always const so the const keyword is optional.

// With parens

if (result); mut value {
    assert(value  == 12)
} else; err {
    panic(err)
}

fn someFunc(): void! {
    if bad_thing {
        return error::BadError
    } elif return_early {
        return
    }

    // do stuff
}

// [ERROR HANDLING] -------------------------------------------------------------------------------

// panic() will cause the program to exit when it is called.
panic("Some error!")
panic(err)
// The messagfe gets printed just before the program exits.

// panic is an oveloaded function that is always available.
fn panic overloads { panicMsg, panicErrorable }

// assert will panic with an optional message if the given statement is false.
assert(true == false) // Will panic.
assert(true == false, "True is not false!") // Will panic with the given message.
// Like panic assert is always available.

// There is a global error type that is like an enum except the values are global.
// It can be thought of as a global enum

typedef FileError error {
    FileNotFound,
    AccessDenied,
    OutOfMemory,
}

typedef MemoryError error {
    OutOfMemory, // Has the same value as OutOfMemory above.
}

// Functions can return errors.
fn someFunc() error {
    return error::OutOfMemory
}

// Functions can also return specific error types.
fn someFunc() FileError {
    return error::OutOfMemory
    return error::Unknown // Invalid, Unknown is not a FileError
}

// Or
fn someFunc() FileError {
    return FileError::OutOfMemory
}

// Or
fn someFunc() error {
    return FileError::OutOfMemory
}

fn someFunc() FileError {
    return error::Unknown // Invalid, Unknown is not a FileError. Will not compile.
}

// Errors can be wrapped in an optional error message.
fn openFile(filename string) ^File! { // The syntax ^File! is equivalent to Result<^File> and is covered in the Result section.
    file := openFileLogicHere(filename)
    if file == null {
        return errors::wrap(error::FileNotFound, "Failed to open file '{}'", filename) // Optionally wrap error with error message.
    }

    return file
}

fn someFunc() error {
    // The syntax [err] is called payload capturing.
    file := openFile("bla") => [const err] {
        return errors::wrap(err, "someFunc") // The error message will now be "someFunc: Failed to open file 'bla'"
    }

    return 0 // This is the same as return error::None
}


fn canError() error {
    if random::boolean() {
        return error::Unknown
    }

    return error::None // This is the same as return 0
}

fn someFunc() error {
    err := canError()
    if err != error::None {
        return err
    }

    // Is the same as
    err := canError()
    if err != 0 {
        return err
    }

    // Is the same as
    try canError()
}

// 0 is the only numeric value that can be checked against. error::None is guaranteed to always be 0.
err := someFunc()
if err != 0 { /- ... -/ }

if err == 2 // Invalid, will not compile.
if err == FileError::OutOfMemory // Valid.

// Error codes are not guaranteed to have the same value every compilation.
// Because of this it is not recommended to save errors by their code. Rather if errors are going
// to be saved their error message should be saved if they have one.

// So for instance if you had a toml file with
lastError = 235
// This is bad and may not mean the correct error next compliation.
// Rather it should be
lastError = "FileError::NotFound"
// Or
lastError = "error::NotFound"
// Or
lastError = "NotFound"

// To get the error code use
lastErrorName := "NotFound"
lastError := errors::errorForName(lastError)

//
fn someFunc(): int! { /- ... -/ }
idx := someFunc() => [const err] { 
    panic(err)
}

// [TESTS] ----------------------------------------------------------------------------------------

// Nifty has built-in testing. Tests are not compiled into the executable in neither debug nor
// release modes.

// The tests setup the implicit context to have a test struct in the user data. The tests functions
// like expectEq can use that to pass/fail individual tests and keep track of where tests failed
// and what tests were skipped.

using testing // For functions like expect, expectEq, etc

fn add(x, y: int): int {
    return x + y
}

test "add 2, 2" {
    try expectEq(4, add(2, 2))
}

test "fail but continue" {
    expectEq(5, add(2, 2)) // Still fails the test but doesn't exit early.
    try expectEq(4, add(2, 2))
}

test "fail and exit early" {
    try expectEq(5, add(2, 2)) // Fails the test and exits early.
    try expectEq(4, add(2, 2))
}

test "basic while test" {
    x := 0
    while (x <= 100) {
        ++x
    }
    
    try expectEq(x, 100)
}

// To skip a test use the skip keyword.
test skip "this will be skipped" {
    try expect(true)
}

skip test "this will be skipped" {
    try expect(true)
}

// Tets don't have to have a name

test {
    try expectEq(add(2, 2), 4)
}

// Unnamed tests can be skipped

skip test {
    try expect(false)
}

// or

test skip {
    try expect(false)
}

// skip can't be used on it's own

skip "this will be skipped" { // Invalid
    try expect(false)
}

skip { // Invalid
    try expect(false)
}

fn someFunc(data: SomeStruct): !bool {
    // ...
}

test "test error" {
    badData ::= SomeStruct{}
    res ::= someFunc(badData)
    try expectError(res)
    try expectErrorToBe(res, Error("bad data"))
}

#[timeout=100] // Set the timeout for this specific test to 100 seconds.
test "long test" {
    // Long test here
}

#[timeout=100] // Seconds
#[timeout_ms=100] // Milliseconds
#[timeout_us=100] // Microseconds
#[timeout_ns=100] // Nanoseconds

// Have a timeout option for tests.
// A timeout option for individual tests and the test command as a whole.

// expect(), expectEq() return bool!.

// Tests can be written in to any nify file. They can also be in their own files in the format of *.test.nifty

// To run the tests
// nifty test
// Will run all the test files.

// To run a specific test file
// nifty test while.test.nifty

// To run a specific test in a specific test file
// nifty test while.test.nifty "basic while test"

// To run tests starting with a specific string
// nifty test filter "math"
// Unnamed tests are still ran.

// [IMPLICIT CONTEXTS] ----------------------------------------------------------------------------

// Every function in nufty has an implicit context that gets passed to it, unluess #[no_context] is
// used. The context can be used to modifty how existing libraries allocate memory or do logging.

fn someFunc() {
    context->userIndex = 123
    
    newContext := mem::clone(context)
    newContext->allocator = someCustomAllocator
    newContext->userIndex = 456
    
    {
        // Push the context, making it the current context, pops at the end of the scope.
        #push_ctx(newContext) 
        otherFunc()
    }
    free(newContext)
    
    assert(context->userIndex == 123) // True
}

fn otherFunc() {
    ptr := new(int) // When called from someFunc() this uses someCustomAllocator.
    x^ = 12
    println(x^) // 12
    free(x) // When called from someFunc() this uses someCustomAllocator.
    
    assert(context->userIndex == 456) // True when called from someFunc().
}

#[no_context]
fn no_context_func() {
    fmt::println(context->userIndex) // Invalid, context is not defined anywhere.
}

// By default the context is implicitly passed in as 'context'. This can be changed with a receiver
// argument.

fn someFunc[ctx: ^Nifty_Context](x: int) {
    ctx->userIndex = x
}

// Contexts could also be used for thread safe memory management as each thread would have a
// different context.

// The context struct will look something like this:

typedef Nifty_Context struct {
    allocator: does Allocator
    allocatorTmp: does Allocator
    assertionFailure: fn(prefix, msg: string, loc: Source_Location)
    logger: does Logger
    
    userData: rawptr
    userIndex: int
    
    internal: rawptr #[compiler]
}

// [MACROS] ---------------------------------------------------------------------------------------

// Nifty has an intentionally very limited subset of macros mainly meant for compiletime decisions.

#define SOME_CONST_MACRO
// SOME_CONST_MACRO is defined but doesn't have a value.

#build_if(SOME_CONST_MACRO) {
    // Code to comile if SOME_CONST_MACRO is defined (not a scope)
} #else {
    // Code to compile if SOME_CONST_MACRO is not defined (not a scope)
}

#undef SOME_CONST_MACRO
// SOME_CONST_MACRO is no longer defined.

// Values can not be set with #define. This just defines the macro internally in the compiler.
// To set values in a macro use #set. The values being set must be resolvable at compile time.
// It does not work like c/c++ where the macro is replaced by the expanded contents of the macro.
// They MUST resolve to a constant value. Macros are type checked as well, unlike in c/c++.

#set OTHER_CONST_MACRO 12

// Macro values can be used by variables as well.
someVar := #OTHER_CONST_MACRO
// When macro values are used outside of other macros they must start with a '#'.
someVar := OTHER_CONST_MACRO // Invalid

#build_if_true(OTHER_CONST_MACRO == 12) {
    // ...
}

#unset OTHER_CONST_MACRO
// OTHER_CONST_MACRO is no longer set to anything or defined.

// I've decided to not allow user defined macro functions for simplicity. Macros can easily be
// abused and make code VERY hard to read. This could change in the future as macros can be very
// powerful if done correctly.

// Macros can't be set to other macros.
#set THIRD_CONST_MACRO OTHER_CONST_MACRO // Invalid

// Built in macros
// Some of the built in macros are more like keywords than macros. This is because they are useful
// and help out the compiler but are not expected to be used frequently enough to merit their own
// keyword. For instance #number

#file             // replaced with the filename
// #fileRaw          // usually the same as #file but if in a macro will show the filename the macro is in, not where it is used
#path             // replaced with the full file path
// #pathRaw          // usually the same as #path but if in a macro will show the path the macro is in, not where it is used
#line             // replaced with the line the macro is on
// #lineRaw          // usually the same as #line but if in a macro will show the line in the macro, not where it is used
#location()       // replaced with the location of the given function/variable/struct/other. If no argument is given then
                  // the current location is used. The location is a struct with the filename, path, and line.
#caller_location  // replaced with a struct containing the calling function's location
#function         // replaced with the function name the macro is in
#namespace        // replaced with the name of the current namespace
#os               // replaced with the OS that the compiler is running on currently
#build_if()       // will build the file/block only if the argument is defined
#build_if_any()   // will build the file/block only if one or more of the arguments is defined
#build_if_not()   // will build the file/block only if none of the arguments are defined
#build_if_all()   // will build the file/block only if all of the arguments are defined
#build_if_true()  // will build the file/block onlyif all of the arguments evaluate to true
#build_if_false() // will build the file/block onlyif all of the arguments evaluate to false
#time             // replaced with the current time HH:MM:SS
#date             // replaced with the current date yyyy-mm-dd

// The raw macros are commented out because they are currently unnecessary. But if I decide to
// allow user defined function macros they will be useful to have so they stay on the list for now.

#nifty_version       // replaced with the version of the nifty compiler
#nifty_version_major //
#nifty_version_minor //
#nifty_version_patch //
#opt                 // replaced with the current optimization level

#counter             // replaced by an incremented value starting at 0, it is incremented everytime it is encountered and never reset
#jot                 // replaced by an incremented value starting at 0, it is incremented everytime it is encountered and reset every block

#number              // used by generics, see the section on generics for details
#decimal             // used by generics, see the section on generics for details
#integer             // used by generics, see the section on generics for details
#boolean             // used by generics, see the section on generics for details

#no_bounds_check     // does not check bounds in the given block or statement
#check_bounds        // will always check bounds in the given block or statement

#strict_ieee         // ignores IEEE breaking optimizations for the code block. If an algorith relies
                     // on IEEE correctness then this should be used while the optimizations can be 
                     // used in the rest of the code. Some optimizations may still happen anyway as
                     // they can be a thread level optimization (e.g. flush to zero). If that is the
                     // case for you then glhf.

#push_ctx(context: ^Nifty_Context) // Sets the current context.
#pop_ctx(): ^Nifty_Context // Pops the current context and returns it. The current context will now be the previous context.
                          // Does nothing if the current context the only context on the stack.

fn someFunc() {
    fmt::println("This code is in {}::{}:{}() L{}", #namespace, #file, #function, #line)
    // This code is in default::main:someFunc() L3
}

// The following don't expand to anything, they are either defined or not.
#OS_MAC
#OS_WINDOWS
#OS_LINUX
#OS_FREE_BSD
#OS_OPEN_BSD
#OS_NONE

#arch // replaced by the system architecture

// The following don't expand to anything, they are either defined or not.
#ARCH_ARM64
#ARCH_AMD64
#ARCH_X86_64
#ARCH_X86

#build_if(OS_MAC) {}
#build_if_true(os == "windows")

// More to be added as support is expanded.

#embed_bytes(path: string, limit: u64 = 0, compress: string = "")  // Loads a file up to limit bytes and returns its contents as a []u8
#embed_string(path: string, limit: u64 = 0, compress: string = "") // Loads a file up to limit bytes and returns its contents as a string
// If compress is set then it will compress the data using the given method. The only option is zlib, more will be added later.
// If limit is 0 for either then there is no limit (until you run out of RAM that is).

// #embed_bytes and #embed_string only embed in the binary on release builds. This is done to speed up
// compile times during development. If not a release build it will be loaded at runtime.

const RAND = #embed_bytes("/dev/urandom") // Will crash the compiler, possibly your computer.
const ARR = #embed_bytes("/dev/urandom", 128) // Type is [N]u8 where N is the number of elements determined at compile time.

mut str: string = #embed_string("hello.txt");
println(str) // hello.txt contents

#env(var: string): string // Used to get environment variables at compiletime. Returns empty string if not found.
compileTimeEnv := #env("SOME_VAR")

#build_if(#env("IS_CI") == "true") { /- ... -/ }

#error(msg: string) // Causes the compiler to error with the given message.
#warn(msg: string) // Causes the compiler to emit a warning with the given message.
#info(msg: string) // Prints the message to stdout.

#todo(msg: string) // Prints the message to stdout prefixed with highlighted "TODO:".

#assert(condition: bool, msg: string = "") // Compiletime assert. Will cause a compiler error with
                                           // with the optional message on failure.

#len(t: T) // Returns the length of a string or an array (number of items).
#cap(t: T) // Returns the capacity of an array (how many items can be in the array).
#size(t: T) // Returns the size of an array or string in bytes. 

// [MISC] -----------------------------------------------------------------------------------------

b := false
assert(type_of(b) == bool) // true
assert(typename_of(b) == "bool") // true

mut c: type_of(b) // c is type bool
assert(type_of(c) == bool) // true
assert(typename_of(c) == "bool") // true

a := typeid_of(bool)
x := 12
b := typeid_of(type_of(x))

typename_of() // Returns string
type_of() // Returns type
typeid_of() // Returns typeid
typeinfo_of() // Returns TypeInfo struct (?)

num := 42.f
assert(size_of(num) == 4) // true

typedef Point struct {
    x: f32
    y: f32
}

assert(align_of(Point) == 4) // true

restrict // See https://en.wikipedia.org/wiki/Restrict

fn updatePointers(restrict ptrA: ^int, restrict ptrB: ^int, restrict value: ^int) {
    ptrA^ += value^
    ptrB^ += value^
}

fn updatePointers(restrict ptrA, ptrB, value: ^int) { /- ... -/ }
// It is important to note that if the function is formed like this 'restrict' only applies to ptrA.
fn updatePointers(restrict ptrA, restrict ptrB, restrict value: ^int) { /- ... -/ } // Better

// If you need to use existing c code you can use the 'extern' keyword.

package nsl namespace libc

// To tell nifty what is being used you must define everything with extern and the library name.
// Let nifty know what is in the libc namespace.
#[calling_convention="c"]
extern "libc.lib" {
    typedef size_t as uint
    // typedef size_t undefined
    
    EOF ::= -1
    mut stderr: ^FILE
    mut errno: int
    
    fn fclose(file?: ^FILE): int undefined
    fn fflush(file?: ^FILE): int undefined
    
    // The underscore at the front of the function doesn't mean anything here. 
    // Everything in the extern block is public.
    #buildIf(OS_WINDOWS) { fn _aligned_malloc(size, alignment: size_t): rawptr undefined }
    #buildIfNot(OS_WINDOWS) { fn aligned_alloc(alignment, size: size_t): rawptr undefined }
    // extern functions do not have a context passed to them.
}

// Extern namesapces bahave like normal outsize of the 'extern' block.
fn getErrno(): int {
    return errno
}

// Use an extern namespace like normal

namespace main

use libc

fn main() {
    // some code
    res := libc::fflush(^file)
    err := libc::getErrno()
}

// asm will be experimental at first.

#[asm_return]
fn power2(num, power: int): int {
    #asm {
        mov eax, num   // First arg
        mov ecx, power // Second arg
        shl eax, cl    // eax = eax * (2 ** cl)
    }
    
    // Return value is stored in eax, so no return statement.
}

// Wrapping operators

// Integers are not allowed to overflow by default. But sometimes overflow is acceptable. In those
// cases wrapping operators can be used.
%+, %-, %*, %/, %+=, %-=, %*=, %/=, %++, %--

x : u8 = 255
x @+= 1
assert(x == 0)

// Saturating operators

// Integer overflow is undefined behavior so it is not allowed. Saturating operators will not cause
// integer overflow. Instead they will be clamped to the minimum/maximum of the type.
@+, @-, @*, @/, @<<, @+=, @-=, @*=, @/=, @<<=, @++, @--

x := math::MAX_INT
x @+= 1
assert(x == math::MAX_INT) // true

// #[unpredictable] is used to indicate that a branch condition is unpredictable by hardware
// mechanisms such as branch prediction logic

#[unpredictable]
if (unpredictableCondition) {
    // ...
}

#[unpredictable]
when (x) {
    // ...
}

#[unreachable]
// code

// Windows only. Use the console attribute to force the console to always be open for graphical
// programs. This attribute is only valid on the main function. On non-windows platforms this
// attribute does nothing.
#[console]
fn main() {
    // ...
}

// Same as above but only in debug mode.
#[debug_console]
fn main() {
    // ...
}

// [BUILDING] [CONFIG] ----------------------------------------------------------------------------

// The build file is done with TOML. The default build file name is 'build.toml'.
// Each build file can have multiple targets.

// A common usecase for having multiple targets is having a debug build and a production build.

project = string

[<TargetName:string>]
outputName = string 
// Name of the output.
description = string
// Description of the target.
entryPoint = string 
// The file containing 'main()'.
noMain = bool 
// Set to true to remove the requirement for a 'main()' function. Defaults to false.
cmdOnly = bool
// Set to true if there is no code to compile for the target. Defaults to false.
commands = [[string], [string]]
// List of commands to be executed. Can only be used if cmdOnly is true.
noDeprecated = bool 
// Error if a function marked deprecated is used. Disabled by default.
noGoto = bool 
// Error if goto is used. Enabled by default.
debug = bool 
// Compile to debug mode. Disabled by default.
defines = [string] 
// defines = ["name=value", "name2=value2"]
errorOnWarn = bool 
// Treat warnings as errors. Disabled by default.
noWarn = bool 
// Disable warnings. Disabled by default.
optimization = string 
// Sets the optimization level. Options are none, fast, size, debug. 
// Defaults to "none". This is set to 'debug' if debug mode is enabled.
default = bool 
// Defaults to true in the first target, otherwise false. Can only be true for one target at a time.
boundsChecks = string 
// When to check bounds. Options are always, debug, never.
children = [string]
// List of child targets that will be run when this target is complete.
disallowNull = bool
// If eanbled pointers will not be allowed to be null. Defaults to false.
macroRecursionDepth = int
// The number of nexted macros that are allowed to exist. Defaults to 2.
executeBefore = [[string], [string]]
// Array of paths to scripts or commands to be executed before compiling begins.
executeAfter = [[string], [string]]
// Array of paths to scripts or commands to be executed after compiling finishes.
// executeBefore, and executeAfter can be set to only execute on a certain platform
executeBefore = [["windows"], ["some/path/script.bat"]] // Will only run on windows.
executeBefore = [["unix"], ["some/path/script.sh"]] // Will only run on unix-like systems (mac, linux, bsd).
executeBefore = [["mac"], ["macSpecificCmd -withArg"]] // Will only run on mac.
// The above 3 examples can all be in the same project simultaneously and will be executed in order.
// To run on all use 'all'.
executeAfter = [["all"], ["bla"]]
// Valid options are mac, windows, linux, unix, bsd, freeBsd, openBsd, all.
// Where unix is a superset of linux, mac, bsd.
// Where bsd is a superset of freeBsd, openBsd.
deprecatedAfterWarnWithin = int
// If deprecated_after is used on a function this will start emitting a warning x number of days before
// the date given to deprecated_after that the function will be deprecated soon. Disabled if <= 0. Defaults to 0.
noUnusedOnErrorReturn = bool
// Don't allow unused to be used on functions that return errors or results. Disabled by default.
fastMath = bool
// Like -ffast-math in GCC, False by default. Enabled with optimization="fast".
finiteMathOnly = bool
// Disabled by default. Enabled with optimization="fast", or fastMath=true
associativeMath = bool
// Disabled by default. Enabled with optimization="fast", or fastMath=true
unsafeMathOptimization = bool
// Disabled by default. Enabled with optimization="fast", or fastMath=true

// Options that are enabled by other options such as finiteMathOnly can overwrite those options.
optimization = "fast"
finiteMathOnly = false // All the other optiomizations from "fast" are still enabled.

// Where to look for namespaces.
includeDirectories = [string]

/-

nifty new // Interactive dialog to create a new nifty project

nifty build // Builds using the default build file in the current directory.
nifty build [fileName.extension] // Builds using the specified build file or source file.
nifty build [targetName] // Builds using the specified target with the default build file.
nifty build [buildFile]:[targetName] // Builds using the specified target with the specified build file.

nifty run // Takes the same arguments as 'nifty build' but builds and then runs the project.

nifty run prod // Builds and runs using 'build.toml' with target 'prod'.
nifty run server:debug // Builds and runs using 'server.toml' with target 'debug'

When not specifying a target the first target is used by default. Targets can optionally be marked
as the default. Only one target may be marked as default at a time.

nifty create [options] // Creates a new nifty project. Like nifty new but requires no user interaction.
nifty create name=tst

If no command is given then 'run' is used by default.

nifty [fileName.extension] // Same as nifty run [fileName.extension]
nifty [targetName] // Same as nifty run [targetName]
nifty [buildFile]:[targetName] // Same as nifty run [buildFile]:[targetName]
nifty // Will run the default target in the default build file.

If a target has the same name as a command then the command must be used as well.
For instance if you had a build target you would have to use
nifty run build
or
nifty build build

To list all of the targets and their descriptions for the default build file use
nifty targets

To specify a build file to list use
nifty targets [buildFile]

To delete compiled files for a nifty project use
nifty clean

To delete compiled files for a specific target use
nifty clean [targetName]

-/

/-

Nifty will also eventually have two standard tools. A nifty LSP (Language Server Protocol) called Dandy
and a code formatting tool called Neato. Neato will be configurable to run everytime a file in a watched
directory is updated.

-/

// [KEYWORDS] -------------------------------------------------------------------------------------

if
else
elif
while
until
for
return
when
break
continue
impl
constimpl
endimpl
in
defer
defer_err
try
restrict
goto
cast
recast
auto_cast
typename_of
type_of
typeid_of
typeinfo_of
size_of
align_of
new
free
null
unused
undefined
true
false
namespace
package
api
use
using
as
extern
behavior
does
struct
enum
bool b8 b16 b32 b64
char
string cstring
int uint
float double
s8 s16 s32 s64 s128
u8 u16 u32 u64 u128
f16 f32 f64
void
typeid
rawptr uintptr
mut
const
fn
md
typedef
typename

// Keywords that can be used as variables/function names
test
skip
as
in

// Built in functions
assert() // In debug and release mode.
assert_db() // Only in debug mode.
panic()

// [TODO / IDEAS] ---------------------------------------------------------------------------------

/-

If there is a question mark after that means I'm not sure if I want to add that
to the language. Otherwise it is something I want in the language I just haven't
written it into the spec yet.

SOA data types
complex types // Will be in nsl
quaternion types // Will be in nsl
explicit little/big endian types (?)
matrix type // Will be in nsl
map type // Will be in nsl

coroutines/channels/processes (?)
compiletime code execution with #run (JIT)
insert code from a string or code at compiletime with #insert
#expand to turn functions into macros (?)
get access to AST at compiletime
user attributes (possibly explaned in nsl)
time traveling debugger (?)
translate c code to nifty (extra feature)
c backend (?)
compatibility with c ABI (for X system)
undefined behavior for unsigned integer overflow
build artifact caching
unreachable (?)

build system done in nifty instead of a toml project file, build.nifty (project.build.nifty ?)

pipe operator
foo(bar(baz(new_function(other_function()))))
becomes
other_function() |> new_function() |> baz() |> bar() |> foo()

Shoould x be marked as write only until it's written to (compiletime)?
mut x: int = undefined
y := x // Error? Warning?

-/

// Include c code and use it. 

use extern "raylib.h" as raylib

fn main() {
    SCREEN_WIDTH  ::= 1024
    SCREEN_HEIGHT ::= 600
    
    raylib::InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "basic raylib window")
    defer raylib::CloseWindow()
    
    until raylib::WindowShouldClose() {
        raylib::BeginDrawing()
        defer raylib::EndDrawing()
        
        raylib::ClearBackground(raylib::RAYWHITE)
        raylib::DrawText("Hello, world!", 100, 100, 20, raylib::BLACK)
    }
}

// Symbol table, takes namespace name and symbol name as keys
// Have an imported table for symbold from other namespaces that have been brought into the current namespace/scope

fn printValues(fmt: string, values: ..unknown_type) {
    // ...
}

fn printValue(value: unknown_type) {
    // ...
}

fn print overloads { printValues, printValue }

fn printValuesLn(fmt: string, values: ..unknown_type) {
    printValues(fmt, args)
    print("\n")
}

fn printValueLn(value: unknown_type) {
    printValue(value)
    print("\n")
}

fn println overloads { printValuesLn, printValueLn }

// A tuple is an ordered, immutable collection of elements.
// Basically an anonymous struct.

values := .{1234, 12.f, true, "yeet"}
yeet := values.3
newValues := values + .{"bla"}
bla := newValues[4]

newValues.length() == 5 // true

// Destructuring can also be used to access the elements.
const [a: int, b: f32, c: bool, d: string] := values
// or
const [a, b, c, d] := values

tuple := .{123, 456, "abc", "def", false}

fn returnTuple(): .{int, string, f32} {
    return .{123, "abc", 12.f}
}

fn takesTuple(tuple: .{int, string, bool}) {
    if tuple.0 == 12 {
        // do stuff
    }
}

typedef TwoInt as .{int, int}

fn getPosition(): TwoInt {
    x := someFuncX()
    y := someFuncY()
    return .{x, y}
}

mut [x, y] := getPosition()

// [NSL] ------------------------------------------------------------------------------------------

/-

math
    random
    noise
    big
    complex
    matrix
    vector

config
    toml
    json
    yaml
    env

network
    ftp
    udp
    http
    websocket
time
os
reflection

compress
    zlib

crypto
    bcrypt
    aes
    sha256
    sha512
    md5

encoding
    base32
    base64
    csv
    hex

fmt
io
hash
fs
    path

thread
window

collection
    map
    queue
    stack
    vector
    list (linked list)
    btree

db
    mysql
    
regex

Optionals

sdl
glfw
dear_imgui
lua
stb
    image

vulkan

-/
