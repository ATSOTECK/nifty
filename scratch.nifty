
fn add(a, b int) int {
    ret := a + b
    return ret
}

fn main() int {
    return add(2, 2)
}

typedef NewUser struct {
    name: string,
    age: int,
}

typedef User struct {
    ...NewUser,
    id: string,
}

/-

a: {
    name: "a",
    fileName: "scratch.nifty",
    kind: int
    mutable: false
    valueSet: false

}
b
ret

-/

fmt::println("Putting {fmt::green}{filename}{fmt::reset} message.")
// The above could be auto converted into below during compilation.
fmt::println("Putting {}{}{} message.", fmt::green, filename, fmt::reset)
// Or
fmt::println("Putting {:green}{filename}{:reset} message.")
// Which would be compiled to
fmt::println("Putting {:green}{}{:reset} message.", filename)

// To do formatting use a colon after the opening brace.
x ::= 1.234567
fmt::println("{:.3}", x)
fmt::println("{x:.3}")

using map

fn main() {
    map := Map<string, int>{}
    a := map.get("thing")
    b := map.get("other", 12)
}

package nsl namespace map

typedef Map<typename T, typename U> struct {
    //
}

constimpl Map<typename T, typename U>

md getValue(key: T): U? {}
md getWithDefault(key: T, default: U): U {}

md get overloads {getValue, getWithDefault}

md set(key: T): bool {}
md erase(key: T): bool {}

endimpl

use net::http;
use os;
using fmt;
use { green, reset } in fmt::colors;

fn put_message(filename: string): error {
    println("Putting {green}{filename}{reset} message.");
    data ::= try os::read_file("{filename}.json");
    resp ::= try http::put("localhost:4001/prerecorded_messages", { "Content-Type": "application/json" }, data);
    println(resp);
}

fn put_message(filename: string): error {
    println("Putting {green}{filename}{reset} message.");
    data ::= try os::read_file("{filename}.json");
    req := try http::new_request(http::Method::Put, "localhost:4001/prerecorded_messages");
    req.header.set("Content-Type", "application/json");
    req.payload = data;
    
    resp ::= try http::send(req);
    
    println(resp);
}

fn put_message(filename: string): error {
    println("Putting {green}{filename}{reset} message.");
    data ::= try os::read_file("{filename}.json");
    resp ::= try http::request(http::Method::Put, "localhost:4001/prerecorded_messages", { "Content-Type": "application/json" }, data);
    println(resp);
}

fn main() {
    err ::= put_message("sub-req");
    if err != 0 {
        panic(err);
    }
}


// Parsing args

use flags
use errors
use fmt
use strconv

typedef Options struct {
    filename : string; #[flag="f", required, usage="File to load."]
    count    : int;    #[usage="Usage info here", default=2]
    overwrite: bool;   #[usage="Overwrite the file", default=true]
}

fn type_setter<typename T>(data: ^T, value: string, attributes: []string): bool! {
    when typeid_of(T) {
        Some_Type: {
            data->bla = strconv::to_lower(value);
            return true;
        }
    }

    return false;
}

fn type_setter(data: ^unknown_type, value: string, attributes: []string): bool! {
    when type_of(data) {
        Some_Type: {
            data->bla = strconv::to_lower(value);
            return true;
        }
    }

    return false;
}

fn validator(name: string, value: unknown_type, attributes: []string) error {
    if name == "count" {
        c ::= cast(value, int)
        if c <= 0 || c > 5 {
            return errors::wrap(error::FlagError, "count must be > 0 and <= 5");
            // return fmt::errorf(error::FlagError, "count must be > 0 and <= 5");
        }
    }

    return error::None;
}

fn main(args: []string): int {
    opts ::= flags::parse_args_strict<Options>(args, validator, type_setter) => [const err] {
        panic(err);
    };

    // or

    res ::= flags::parse_args<Options>(args, validator, type_setter);
    if res.errors.length() > 0 {
        for const err in res.errors {
            fmt::println(err);
        }

        return 1;
    }

    opts ::= res.data ?? Options{};

    for i := 0; i < opts.count; ++i {
        // do something
    }

    return 0;
}


arr := []int{1, 2, 3}

len ::= #len(arr)
cap ::= #cap(arr)
#append(arr, 12) // [1, 2, 3, 12]
#prepend(arr, 42) // [42, 1, 2, 3, 12]
#clear(arr)

arr1 := []int{1, 2, 3}
arr2 := []int{4, 5, 6}

#append(arr1, arr2)
fmt::printf(arr1) // [1, 2, 3, 4, 5, 6]

// More advanced array functions are in the arrays namespace.

arrays::map(arr, fn (x: int) {
    //
});

//

typedef Foo behavior {
    ^Bar(): string // Reciever obj must be a pointer.
}

fn add_small_ints<typename T: #integer>(a, b: T): T {
    #if(size_of(T) > 16) {
        #error("too big");
    }

    return a + b;
}


// With #[constexpr] all args must be determined at compile time.
#[constexpr]
fn Vec(T: typeid, N: int): typeid {
    vec_type := struct {
        data: [N]T;
    }

    impl vec_type;

    md abs[v: Self](): Self {
        tmp := Self{data: undefined}
        for const n, i in v.data {
            tmp.data[i] = n;
        }

        return tmp;
    }

    md init(data: [N]T) {
        return Self{data: data};
    }

    endimpl;

    return vec_type;
}

constexpr x = Vec(s32, 3).init([]s32{1, -2, 3});
constexpr y = x.abs();
